{"version":3,"sources":["base/layout/rocketbelt.flexibility.min.js"],"names":["window","flexibility","Array","prototype","forEach","callback","undefined","this","TypeError","Function","object","Object","scope","arguments","arraylike","String","split","length","Math","max","min","index","call","root","factory","define","amd","exports","module","computeLayout","fillNodes","node","layout","isDirty","width","height","top","left","right","bottom","style","children","measure","Error","isUndefined","value","isRowDirection","flexDirection","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_ROW_REVERSE","isColumnDirection","CSS_FLEX_DIRECTION_COLUMN","CSS_FLEX_DIRECTION_COLUMN_REVERSE","getLeadingMargin","axis","marginStart","marginLeft","marginRight","marginTop","marginBottom","margin","getTrailingMargin","marginEnd","getLeadingPadding","paddingStart","paddingLeft","paddingRight","paddingTop","paddingBottom","padding","getTrailingPadding","paddingEnd","getLeadingBorder","borderStartWidth","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","borderWidth","getTrailingBorder","borderEndWidth","getLeadingPaddingAndBorder","getTrailingPaddingAndBorder","getBorderAxis","getMarginAxis","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignContent","alignContent","getAlignItem","child","alignSelf","alignItems","resolveAxis","direction","CSS_DIRECTION_RTL","resolveDirection","parentDirection","CSS_DIRECTION_INHERIT","CSS_DIRECTION_LTR","getFlexDirection","getCrossFlexDirection","getPositionType","position","isFlex","CSS_POSITION_RELATIVE","flex","isFlexWrap","flexWrap","getDimWithMargin","dim","isDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","boundAxis","row","minWidth","row-reverse","column","minHeight","column-reverse","maxWidth","maxHeight","boundValue","fmaxf","a","b","setDimensionFromStyle","setTrailingPosition","trailing","getRelativePosition","leading","layoutNodeImpl","parentMaxWidth","parentMaxHeight","mainAxis","crossAxis","resolvedRowAxis","childCount","paddingAndBorderAxisResolvedRow","paddingAndBorderAxisColumn","isResolvedRowDimDefined","CSS_UNDEFINED","isRowUndefined","isColumnUndefined","measureDim","i","ii","isNodeFlexWrap","leadingPaddingAndBorderMain","leadingPaddingAndBorderCross","paddingAndBorderAxisMain","paddingAndBorderAxisCross","isMainDimDefined","isCrossDimDefined","isMainRowDirection","firstAbsoluteChild","currentAbsoluteChild","definedMainDim","startLine","endLine","alreadyComputedNextLayout","linesCrossDim","linesMainDim","linesCount","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","isSimpleStackMain","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","firstComplexMain","isSimpleStackCross","firstComplexCross","firstFlexChild","currentFlexChild","mainDim","crossDim","lineIndex","nextAbsoluteChild","nextFlexChild","alignItem","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","nextContentDim","layoutNode","CSS_ALIGN_FLEX_START","leadingMainDim","betweenMainDim","remainingMainDim","baseMainDim","boundMainDim","flexibleMainDim","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","containerCrossAxis","leadingCrossDim","remainingCrossDim","CSS_ALIGN_CENTER","nodeCrossAxisInnerSize","remainingAlignContentDim","crossDimLead","currentLead","CSS_ALIGN_FLEX_END","endIndex","startIndex","lineHeight","alignContentAlignItem","childHeight","needsMainTrailingPos","needsCrossTrailingPos","shouldUpdate","skipLayout","lastLayout","requestedHeight","requestedWidth","addEventListener","attachEvent","Window","HTMLDocument","Element","type","listener","removeEventListener","detachEvent","detect","document","createElement","display","error","documentElement","currentStyle","onresize","target","init","details","onlayoutcomplete","TIMEOUT","SECOND","FRAMES_PER_SECOND","VIEWPORT_ELEMENT","VIEWPORT_WIDTH","VIEWPORT_HEIGHT","event","clientWidth","clientHeight","clearTimeout","nodeType","walk","setTimeout","CSS_FLEX_CONTAINER_PROPERTIES","initial","valid","boxSizing","updateFlexContainerCache","getCSS","ie9CSS","ffbCSS","replace","$0","key","kabobKey","toLowerCase","keyValue","cssValue","test","CSS_FLEX_ITEM_PROPERTIES","flexBasis","flexGrow","flexShrink","order","updateFlexItemCache","parseFloat","CSS_RESET_TEXT","CSS_BORDER_WIDTHS","medium","none","thick","thin","CSS_LENGTHS","CSS_LENGTH_REGEX","CSS_FULL_LENGTH","updateLengthCache","parentWidth","parentHeight","parentLength","parentNode","clonex","setCSS","runtimeStyle","cssText","fontSize","insertBefore","nextSibling","offsetWidth","offsetHeight","removeChild","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","match","childNodes","childNode","childNodeIndex","childDetails","childStyle","push","sort","childA","childB","reverse","maxLength","maxIndex","angle"],"mappings":"CACA,WACEA,OAAOC,eAEFC,MAAMC,UAAUC,UACnBF,MAAMC,UAAUC,QAAU,SAAiBC,GACzC,GAAaC,SAATC,MAA+B,OAATA,KACxB,KAAM,IAAIC,WAAUD,KAAO,mBAG7B,MAAMF,YAAoBI,WACxB,KAAM,IAAID,WAAUH,EAAW,qBASjC,KANA,GAAIK,GAASC,OAAOJ,MAChBK,EAAQC,UAAU,GAClBC,EAAYJ,YAAkBK,QAASL,EAAOM,MAAM,IAAMN,EAC1DO,EAASC,KAAKC,IAAID,KAAKE,IAAIN,EAAUG,OAAQ,kBAAmB,IAAM,EACtEI,GAAQ,IAEHA,EAAQJ,GACXI,IAASP,IACXT,EAASiB,KAAKV,EAAOE,EAAUO,GAAQA,EAAOX,KAWrD,SAASa,EAAMC,GACQ,kBAAXC,SAAyBA,OAAOC,IAEzCD,UAAWD,GACiB,gBAAZG,SAIhBC,OAAOD,QAAUH,IAGjBD,EAAKM,cAAgBL,KAEvBvB,YAAa,WAUf,GAAI4B,GAAgB,WAuDlB,QAASC,GAAUC,GAoBjB,GAnBKA,EAAKC,SAAUD,EAAKE,UACvBF,EAAKC,QACHE,MAAO5B,OACP6B,OAAQ7B,OACR8B,IAAK,EACLC,KAAM,EACNC,MAAO,EACPC,OAAQ,IAIPR,EAAKS,QACRT,EAAKS,UAGFT,EAAKU,WACRV,EAAKU,aAGHV,EAAKS,MAAME,SAAWX,EAAKU,UAAYV,EAAKU,SAASxB,OACvD,KAAM,IAAI0B,OAAM,kEAIlB,OADAZ,GAAKU,SAASrC,QAAQ0B,GACfC,EAGT,QAASa,GAAYC,GACnB,MAAiBvC,UAAVuC,EAGT,QAASC,GAAeC,GACtB,MAAOA,KAAkBC,GAClBD,IAAkBE,EAG3B,QAASC,GAAkBH,GACzB,MAAOA,KAAkBI,GAClBJ,IAAkBK,EAG3B,QAASC,GAAiBtB,EAAMuB,GAC9B,GAA+BhD,SAA3ByB,EAAKS,MAAMe,aAA6BT,EAAeQ,GACzD,MAAOvB,GAAKS,MAAMe,WAGpB,IAAIV,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAMgB,UAAc,MACxD,KAAK,cAAkBX,EAAQd,EAAKS,MAAMiB,WAAc,MACxD,KAAK,SAAkBZ,EAAQd,EAAKS,MAAMkB,SAAc,MACxD,KAAK,iBAAkBb,EAAQd,EAAKS,MAAMmB,aAG5C,MAAcrD,UAAVuC,EACKA,EAGiBvC,SAAtByB,EAAKS,MAAMoB,OACN7B,EAAKS,MAAMoB,OAGb,EAGT,QAASC,GAAkB9B,EAAMuB,GAC/B,GAA6BhD,SAAzByB,EAAKS,MAAMsB,WAA2BhB,EAAeQ,GACvD,MAAOvB,GAAKS,MAAMsB,SAGpB,IAAIjB,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAMiB,WAAc,MACxD,KAAK,cAAkBZ,EAAQd,EAAKS,MAAMgB,UAAc,MACxD,KAAK,SAAkBX,EAAQd,EAAKS,MAAMmB,YAAc,MACxD,KAAK,iBAAkBd,EAAQd,EAAKS,MAAMkB,UAG5C,MAAa,OAATb,EACKA,EAGiBvC,SAAtByB,EAAKS,MAAMoB,OACN7B,EAAKS,MAAMoB,OAGb,EAGT,QAASG,GAAkBhC,EAAMuB,GAC/B,GAAgChD,SAA5ByB,EAAKS,MAAMwB,cAA8BjC,EAAKS,MAAMwB,cAAgB,GACjElB,EAAeQ,GACpB,MAAOvB,GAAKS,MAAMwB,YAGpB,IAAInB,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAMyB,WAAe,MACzD,KAAK,cAAkBpB,EAAQd,EAAKS,MAAM0B,YAAe,MACzD,KAAK,SAAkBrB,EAAQd,EAAKS,MAAM2B,UAAe,MACzD,KAAK,iBAAkBtB,EAAQd,EAAKS,MAAM4B,cAG5C,MAAa,OAATvB,GAAiBA,GAAS,EACrBA,EAGkBvC,SAAvByB,EAAKS,MAAM6B,SAAyBtC,EAAKS,MAAM6B,SAAW,EACrDtC,EAAKS,MAAM6B,QAGb,EAGT,QAASC,GAAmBvC,EAAMuB,GAChC,GAA8BhD,SAA1ByB,EAAKS,MAAM+B,YAA4BxC,EAAKS,MAAM+B,YAAc,GAC7DzB,EAAeQ,GACpB,MAAOvB,GAAKS,MAAM+B,UAGpB,IAAI1B,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAM0B,YAAe,MACzD,KAAK,cAAkBrB,EAAQd,EAAKS,MAAMyB,WAAe,MACzD,KAAK,SAAkBpB,EAAQd,EAAKS,MAAM4B,aAAe,MACzD,KAAK,iBAAkBvB,EAAQd,EAAKS,MAAM2B,WAG5C,MAAa,OAATtB,GAAiBA,GAAS,EACrBA,EAGkBvC,SAAvByB,EAAKS,MAAM6B,SAAyBtC,EAAKS,MAAM6B,SAAW,EACrDtC,EAAKS,MAAM6B,QAGb,EAGT,QAASG,GAAiBzC,EAAMuB,GAC9B,GAAoChD,SAAhCyB,EAAKS,MAAMiC,kBAAkC1C,EAAKS,MAAMiC,kBAAoB,GACzE3B,EAAeQ,GACpB,MAAOvB,GAAKS,MAAMiC,gBAGpB,IAAI5B,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAMkC,eAAmB,MAC7D,KAAK,cAAkB7B,EAAQd,EAAKS,MAAMmC,gBAAmB,MAC7D,KAAK,SAAkB9B,EAAQd,EAAKS,MAAMoC,cAAmB,MAC7D,KAAK,iBAAkB/B,EAAQd,EAAKS,MAAMqC,kBAG5C,MAAa,OAAThC,GAAiBA,GAAS,EACrBA,EAGsBvC,SAA3ByB,EAAKS,MAAMsC,aAA6B/C,EAAKS,MAAMsC,aAAe,EAC7D/C,EAAKS,MAAMsC,YAGb,EAGT,QAASC,GAAkBhD,EAAMuB,GAC/B,GAAkChD,SAA9ByB,EAAKS,MAAMwC,gBAAgCjD,EAAKS,MAAMwC,gBAAkB,GACrElC,EAAeQ,GACpB,MAAOvB,GAAKS,MAAMwC,cAGpB,IAAInC,GAAQ,IACZ,QAAQS,GACN,IAAK,MAAkBT,EAAQd,EAAKS,MAAMmC,gBAAmB,MAC7D,KAAK,cAAkB9B,EAAQd,EAAKS,MAAMkC,eAAmB,MAC7D,KAAK,SAAkB7B,EAAQd,EAAKS,MAAMqC,iBAAmB,MAC7D,KAAK,iBAAkBhC,EAAQd,EAAKS,MAAMoC,eAG5C,MAAa,OAAT/B,GAAiBA,GAAS,EACrBA,EAGsBvC,SAA3ByB,EAAKS,MAAMsC,aAA6B/C,EAAKS,MAAMsC,aAAe,EAC7D/C,EAAKS,MAAMsC,YAGb,EAGT,QAASG,GAA2BlD,EAAMuB,GACxC,MAAOS,GAAkBhC,EAAMuB,GAAQkB,EAAiBzC,EAAMuB,GAGhE,QAAS4B,GAA4BnD,EAAMuB,GACzC,MAAOgB,GAAmBvC,EAAMuB,GAAQyB,EAAkBhD,EAAMuB,GAGlE,QAAS6B,GAAcpD,EAAMuB,GAC3B,MAAOkB,GAAiBzC,EAAMuB,GAAQyB,EAAkBhD,EAAMuB,GAGhE,QAAS8B,GAAcrD,EAAMuB,GAC3B,MAAOD,GAAiBtB,EAAMuB,GAAQO,EAAkB9B,EAAMuB,GAGhE,QAAS+B,GAAwBtD,EAAMuB,GACrC,MAAO2B,GAA2BlD,EAAMuB,GACpC4B,EAA4BnD,EAAMuB,GAGxC,QAASgC,GAAkBvD,GACzB,MAAIA,GAAKS,MAAM+C,eACNxD,EAAKS,MAAM+C,eAEb,aAGT,QAASC,GAAgBzD,GACvB,MAAIA,GAAKS,MAAMiD,aACN1D,EAAKS,MAAMiD,aAEb,aAGT,QAASC,GAAa3D,EAAM4D,GAC1B,MAAIA,GAAMnD,MAAMoD,UACPD,EAAMnD,MAAMoD,UAEjB7D,EAAKS,MAAMqD,WACN9D,EAAKS,MAAMqD,WAEb,UAGT,QAASC,GAAYxC,EAAMyC,GACzB,GAAIA,IAAcC,EAAmB,CACnC,GAAI1C,IAASN,EACX,MAAOC,EACF,IAAIK,IAASL,EAClB,MAAOD,GAIX,MAAOM,GAGT,QAAS2C,GAAiBlE,EAAMmE,GAC9B,GAAIH,EAWJ,OATEA,GADEhE,EAAKS,MAAMuD,UACDhE,EAAKS,MAAMuD,UAEXI,EAGVJ,IAAcI,IAChBJ,EAAiCzF,SAApB4F,EAAgCE,EAAoBF,GAG5DH,EAGT,QAASM,GAAiBtE,GACxB,MAAIA,GAAKS,MAAMO,cACNhB,EAAKS,MAAMO,cAEbI,EAGT,QAASmD,GAAsBvD,EAAegD,GAC5C,MAAI7C,GAAkBH,GACb+C,EAAY9C,EAAwB+C,GAEpC5C,EAIX,QAASoD,GAAgBxE,GACvB,MAAIA,GAAKS,MAAMgE,SACNzE,EAAKS,MAAMgE,SAEb,WAGT,QAASC,GAAO1E,GACd,MACEwE,GAAgBxE,KAAU2E,IAC1B3E,EAAKS,MAAMmE,KAAO,EAItB,QAASC,GAAW7E,GAClB,MAA+B,SAAxBA,EAAKS,MAAMqE,SAGpB,QAASC,GAAiB/E,EAAMuB,GAC9B,MAAOvB,GAAKC,OAAO+E,GAAIzD,IAAS8B,EAAcrD,EAAMuB,GAGtD,QAAS0D,GAAajF,EAAMuB,GAC1B,MAAiChD,UAA1ByB,EAAKS,MAAMuE,GAAIzD,KAAwBvB,EAAKS,MAAMuE,GAAIzD,KAAU,EAGzE,QAAS2D,GAAalF,EAAMmF,GAC1B,MAA2B5G,UAApByB,EAAKS,MAAM0E,GAGpB,QAASC,GAAiBpF,GACxB,MAA8BzB,UAAvByB,EAAKS,MAAME,QAGpB,QAAS0E,GAAYrF,EAAMmF,GACzB,MAAwB5G,UAApByB,EAAKS,MAAM0E,GACNnF,EAAKS,MAAM0E,GAEb,EAGT,QAASG,GAAUtF,EAAMuB,EAAMT,GAC7B,GAAIzB,IACFkG,IAAOvF,EAAKS,MAAM+E,SAClBC,cAAezF,EAAKS,MAAM+E,SAC1BE,OAAU1F,EAAKS,MAAMkF,UACrBC,iBAAkB5F,EAAKS,MAAMkF,WAC7BpE,GAEEnC,GACFmG,IAAOvF,EAAKS,MAAMoF,SAClBJ,cAAezF,EAAKS,MAAMoF,SAC1BH,OAAU1F,EAAKS,MAAMqF,UACrBF,iBAAkB5F,EAAKS,MAAMqF,WAC7BvE,GAEEwE,EAAajF,CAOjB,OANYvC,UAARa,GAAqBA,GAAO,GAAK2G,EAAa3G,IAChD2G,EAAa3G,GAEHb,SAARc,GAAqBA,GAAO,GAAK0G,EAAa1G,IAChD0G,EAAa1G,GAER0G,EAGT,QAASC,GAAMC,EAAGC,GAChB,MAAID,GAAIC,EACCD,EAEFC,EAIT,QAASC,GAAsBnG,EAAMuB,GAEJhD,SAA3ByB,EAAKC,OAAO+E,GAAIzD,KAIf0D,EAAajF,EAAMuB,KAKxBvB,EAAKC,OAAO+E,GAAIzD,IAASyE,EACvBV,EAAUtF,EAAMuB,EAAMvB,EAAKS,MAAMuE,GAAIzD,KACrC+B,EAAwBtD,EAAMuB,KAIlC,QAAS6E,GAAoBpG,EAAM4D,EAAOrC,GACxCqC,EAAM3D,OAAOoG,GAAS9E,IAASvB,EAAKC,OAAO+E,GAAIzD,IAC3CqC,EAAM3D,OAAO+E,GAAIzD,IAASqC,EAAM3D,OAAOkF,GAAI5D,IAKjD,QAAS+E,GAAoBtG,EAAMuB,GACjC,MAAkChD,UAA9ByB,EAAKS,MAAM8F,GAAQhF,IACd8D,EAAYrF,EAAMuG,GAAQhF,KAE3B8D,EAAYrF,EAAMqG,GAAS9E,IAGrC,QAASiF,GAAexG,EAAMyG,EAAgBC,EAAoCvC,GAChF,GAAuBH,GAAYE,EAAiBlE,EAAMmE,GACZwC,EAAW5C,EAAYO,EAAiBtE,GAAOgE,GAC/C4C,EAAYrC,EAAsBoC,EAAU3C,GAC5C6C,EAAkB9C,EAAY9C,EAAwB+C,EAGpGmC,GAAsBnG,EAAM2G,GAC5BR,EAAsBnG,EAAM4G,GAG5B5G,EAAKC,OAAO+D,UAAYA,EAIxBhE,EAAKC,OAAOsG,GAAQI,KAAcrF,EAAiBtB,EAAM2G,GACvDL,EAAoBtG,EAAM2G,GAC5B3G,EAAKC,OAAOoG,GAASM,KAAc7E,EAAkB9B,EAAM2G,GACzDL,EAAoBtG,EAAM2G,GAC5B3G,EAAKC,OAAOsG,GAAQK,KAAetF,EAAiBtB,EAAM4G,GACxDN,EAAoBtG,EAAM4G,GAC5B5G,EAAKC,OAAOoG,GAASO,KAAe9E,EAAkB9B,EAAM4G,GAC1DN,EAAoBtG,EAAM4G,EAI5B,IAAWE,GAAa9G,EAAKU,SAASxB,OACzB6H,GAAkCzD,EAAwBtD,EAAM6G,GAChEG,GAA6B1D,EAAwBtD,EAAMoB,EAExE,IAAIgE,EAAiBpF,GAAO,CAC1B,GAAYiH,KAA2BpG,EAAYb,EAAKC,OAAO+E,GAAI6B,KAEtD1G,GAAQ+G,CAEnB/G,IADE8E,EAAajF,EAAM6G,GACb7G,EAAKS,MAAMN,MACV8G,GACDjH,EAAKC,OAAO+E,GAAI6B,IAEhBJ,EACNpD,EAAcrD,EAAM6G,GAExB1G,IAAS4G,EAET,IAAa3G,IAAS8G,CAEpB9G,IADE6E,EAAajF,EAAMoB,GACZpB,EAAKS,MAAML,OACVS,EAAYb,EAAKC,OAAO+E,GAAI5D,KAG7BsF,EACPrD,EAAcrD,EAAM6G,GAHb7G,EAAKC,OAAO+E,GAAI5D,IAK3BhB,IAAUkD,EAAwBtD,EAAMoB,EAKxC,IAAY+F,KAAkBlC,EAAajF,EAAM6G,KAAqBI,GAC1DG,IAAqBnC,EAAajF,EAAMoB,IAClDP,EAAYb,EAAKC,OAAO+E,GAAI5D,IAG9B,IAAI+F,IAAkBC,GAAmB,CACvC,GAAiBC,IAAarH,EAAKS,MAAME,QAGvCR,GACAC,GAEE+G,MACFnH,EAAKC,OAAOE,MAAQkH,GAAWlH,MAC7B4G,IAEAK,KACFpH,EAAKC,OAAOG,OAASiH,GAAWjH,OAC9B4G,IAGN,GAAmB,IAAfF,EACF,OAIJ,GAaWQ,IACAC,GACQ3D,GAC2BrC,GAhBlCiG,GAAiB3C,EAAW7E,GAEnBwD,GAAiBD,EAAkBvD,GAE3CyH,GAA8BvE,EAA2BlD,EAAM2G,GAC/De,GAA+BxE,EAA2BlD,EAAM4G,GAChEe,GAA2BrE,EAAwBtD,EAAM2G,GACzDiB,GAA4BtE,EAAwBtD,EAAM4G,GAE3DiB,IAAoBhH,EAAYb,EAAKC,OAAO+E,GAAI2B,KAChDmB,IAAqBjH,EAAYb,EAAKC,OAAO+E,GAAI4B,KACjDmB,GAAqBhH,EAAe4F,GAO7BqB,GAAqB,KACrBC,GAAuB,KAE7BC,GAAiBhB,CAC1BW,MACFK,GAAiBlI,EAAKC,OAAO+E,GAAI2B,IAAagB,GAYhD,KARA,GAAWQ,IAAY,EACZC,GAAU,EAEVC,GAA4B,EAE1BC,GAAgB,EAChBC,GAAe,EACjBC,GAAa,EACjBJ,GAAUtB,GAAY,CAO3B,GA8BajB,IACAC,GA/BA2C,GAAiB,EAInBC,GAAwB,EACtBC,GAAgB,EAClBC,GAA2B,EAM1BC,GACPhB,IAAoBrE,KAAmBsF,IACtCjB,IAAoBrE,KAAmBuF,EAClCC,GAAoBH,GAAoB/B,EAAaqB,GAMpDc,IAAqB,EACtBC,GAAoBpC,EAEZqC,GAAiB,KACjBC,GAAmB,KAEzBC,GAAU5B,GACV6B,GAAW,CAIxB,KAAKhC,GAAIa,GAAWb,GAAIR,IAAcQ,GAAG,CACvC1D,GAAQ5D,EAAKU,SAAS4G,IACtB1D,GAAM2F,UAAYf,GAElB5E,GAAM4F,kBAAoB,KAC1B5F,GAAM6F,cAAgB,IAEtB,IAAmBC,IAAY/F,EAAa3D,EAAM4D,GAIlD,IAAI8F,KAAcC,GACdnF,EAAgBZ,MAAWe,IAC3BmD,KACC7C,EAAarB,GAAOgD,GACvBhD,GAAM3D,OAAO+E,GAAI4B,IAAcZ,EAC7BV,EAAU1B,GAAOgD,EAAW5G,EAAKC,OAAO+E,GAAI4B,IAC1CgB,GAA4BvE,EAAcO,GAAOgD,IAEnDtD,EAAwBM,GAAOgD,QAE5B,IAAIpC,EAAgBZ,MAAWgG,GAapC,IAV2B,OAAvB5B,KACFA,GAAqBpE,IAEM,OAAzBqE,KACFA,GAAqBuB,kBAAoB5F,IAE3CqE,GAAuBrE,GAIlB2D,GAAK,EAAGA,GAAK,EAAGA,KACnBhG,GAAe,IAAPgG,GAAYtG,EAAyBG,GACxCP,EAAYb,EAAKC,OAAO+E,GAAIzD,QAC5B0D,EAAarB,GAAOrC,KACrB2D,EAAatB,GAAO2C,GAAQhF,MAC5B2D,EAAatB,GAAOyC,GAAS9E,OAC/BqC,GAAM3D,OAAO+E,GAAIzD,KAASyE,EACxBV,EAAU1B,GAAOrC,GAAMvB,EAAKC,OAAO+E,GAAIzD,KACrC+B,EAAwBtD,EAAMuB,IAC9B8B,EAAcO,GAAOrC,IACrB8D,EAAYzB,GAAO2C,GAAQhF,KAC3B8D,EAAYzB,GAAOyC,GAAS9E,MAE9B+B,EAAwBM,GAAOrC,KAMvC,IAAasI,IAAiB,CAgE9B,IA5DIhC,IAAoBnD,EAAOd,KAC7B8E,KACAC,IAAiB/E,GAAMnD,MAAMmE,KAIN,OAAnBuE,KACFA,GAAiBvF,IAEM,OAArBwF,KACFA,GAAiBK,cAAgB7F,IAEnCwF,GAAmBxF,GAMnBiG,GAAiBvG,EAAwBM,GAAO+C,GAC9CtD,EAAcO,GAAO+C,KAGvBd,GAAWqB,EACXpB,GAAYoB,EAEPa,GAWDjC,GADEb,EAAajF,EAAMoB,GACTpB,EAAKC,OAAO+E,GAAI5D,IACxB4F,GAEQN,EACVrD,EAAcrD,EAAMoB,GACpB4F,GAdFnB,GADEZ,EAAajF,EAAM6G,GACV7G,EAAKC,OAAO+E,GAAI6B,IACzBE,GAESN,EACTpD,EAAcrD,EAAM6G,GACpBE,GAc4B,IAA9BsB,IACFyB,EAAqClG,GAAOiC,GAAUC,GAAW9B,GAK/DQ,EAAgBZ,MAAWe,KAC7BiE,KAEAiB,GAAiB9E,EAAiBnB,GAAO+C,KAKzCa,IACAK,IACAY,GAAiBoB,GAAiB3B,IAGlCZ,KAAMa,GAAW,CACnBS,KACAP,GAA4B,CAC5B,OAMEQ,KACCrE,EAAgBZ,MAAWe,IAAyBD,EAAOd,OAC9DiF,IAAoB,EACpBG,GAAmB1B,IAMjB2B,KACCzE,EAAgBZ,MAAWe,IACvB+E,KAAcC,GAAqBD,KAAcK,GAClDlJ,EAAY+C,GAAM3D,OAAO+E,GAAI4B,QACnCqC,IAAqB,EACrBC,GAAoB5B,IAGlBuB,KACFjF,GAAM3D,OAAOkF,GAAIwB,KAAc0C,GAC3BxB,IACFzB,EAAoBpG,EAAM4D,GAAO+C,GAGnC0C,IAAWtE,EAAiBnB,GAAO+C,GACnC2C,GAAWtD,EAAMsD,GAAUhE,EAAU1B,GAAOgD,EAAW7B,EAAiBnB,GAAOgD,MAG7EqC,KACFrF,GAAM3D,OAAOkF,GAAIyB,KAAe0B,GAAgBZ,GAC5CI,IACF1B,EAAoBpG,EAAM4D,GAAOgD,IAIrCyB,GAA4B,EAC5BI,IAAkBoB,GAClBzB,GAAUd,GAAI,EAQhB,GAAa0C,IAAiB,EACjBC,GAAiB,EAGjBC,GAAmB,CAShC,IAPEA,GADErC,GACiBK,GAAiBO,GAEjBzC,EAAMyC,GAAgB,GAAKA,GAKlB,IAA1BC,GAA6B,CAC/B,GACayB,IACAC,GAFAC,GAAkBH,GAAmBvB,EAOlD,KADAS,GAAmBD,GACS,OAArBC,IACLe,GAAcE,GAAkBjB,GAAiB3I,MAAMmE,KACnDtB,EAAwB8F,GAAkBzC,GAC9CyD,GAAe9E,EAAU8D,GAAkBzC,EAAUwD,IAEjDA,KAAgBC,KAClBF,IAAoBE,GACpBzB,IAAiBS,GAAiB3I,MAAMmE,MAG1CwE,GAAmBA,GAAiBK,aAWtC,KATAY,GAAkBH,GAAmBvB,GAIjC0B,GAAkB,IACpBA,GAAkB,GAGpBjB,GAAmBD,GACS,OAArBC,IAGLA,GAAiBnJ,OAAO+E,GAAI2B,IAAarB,EAAU8D,GAAkBzC,EACnE0D,GAAkBjB,GAAiB3I,MAAMmE,KACrCtB,EAAwB8F,GAAkBzC,IAGhDd,GAAWqB,EACPjC,EAAajF,EAAM6G,GACrBhB,GAAW7F,EAAKC,OAAO+E,GAAI6B,IACzBE,GACQgB,KACVlC,GAAWY,EACTpD,EAAcrD,EAAM6G,GACpBE,IAEJjB,GAAYoB,EACRjC,EAAajF,EAAMoB,GACrB0E,GAAY9F,EAAKC,OAAO+E,GAAI5D,IAC1B4F,GACOe,KACTjC,GAAYY,EACVrD,EAAcrD,EAAMoB,GACpB4F,IAIJ8C,EAAqCV,GAAkBvD,GAAUC,GAAW9B,GAE5EJ,GAAQwF,GACRA,GAAmBA,GAAiBK,cACpC7F,GAAM6F,cAAgB,SAKfjG,MAAmBsF,IACxBtF,KAAmBuF,EACrBiB,GAAiBE,GAAmB,EAC3B1G,KAAmB8G,EAC5BN,GAAiBE,GACR1G,KAAmB+G,GAC5BL,GAAmBlE,EAAMkE,GAAkB,GAEzCD,GADEvB,GAAwBE,GAA2B,IAAM,EAC1CsB,IACdxB,GAAwBE,GAA2B,GAErC,GAEVpF,KAAmBgH,IAE5BP,GAAiBC,IACdxB,GAAwBE,IAC3BoB,GAAiBC,GAAiB,GAYtC,KAFAZ,IAAWW,GAEN1C,GAAI0B,GAAkB1B,GAAIc,KAAWd,GACxC1D,GAAQ5D,EAAKU,SAAS4G,IAElB9C,EAAgBZ,MAAWgG,IAC3B1E,EAAatB,GAAO2C,GAAQI,IAI9B/C,GAAM3D,OAAOkF,GAAIwB,IAAatB,EAAYzB,GAAO2C,GAAQI,IACvDlE,EAAiBzC,EAAM2G,GACvBrF,EAAiBsC,GAAO+C,IAI1B/C,GAAM3D,OAAOkF,GAAIwB,KAAc0C,GAG3BxB,IACFzB,EAAoBpG,EAAM4D,GAAO+C,GAM/BnC,EAAgBZ,MAAWe,KAG7B0E,IAAWY,GAAiBlF,EAAiBnB,GAAO+C,GAGpD2C,GAAWtD,EAAMsD,GAAUhE,EAAU1B,GAAOgD,EAAW7B,EAAiBnB,GAAOgD,MAKrF,IAAa6D,IAAqBzK,EAAKC,OAAO+E,GAAI4B,GAYlD,KAXKkB,KACH2C,GAAqBzE,EAInBV,EAAUtF,EAAM4G,EAAW0C,GAAW1B,IACtCA,KAKCN,GAAI4B,GAAmB5B,GAAIc,KAAWd,GAGzC,GAFA1D,GAAQ5D,EAAKU,SAAS4G,IAElB9C,EAAgBZ,MAAWgG,IAC3B1E,EAAatB,GAAO2C,GAAQK,IAI9BhD,GAAM3D,OAAOkF,GAAIyB,IAAcvB,EAAYzB,GAAO2C,GAAQK,IACxDnE,EAAiBzC,EAAM4G,GACvBtF,EAAiBsC,GAAOgD,OAErB,CACL,GAAa8D,IAAkBhD,EAI/B,IAAIlD,EAAgBZ,MAAWe,GAAuB,CAGpD,GAAmB+E,IAAY/F,EAAa3D,EAAM4D,GAElD,IAAI8F,KAAcC,EAGZ9I,EAAY+C,GAAM3D,OAAO+E,GAAI4B,OAC/BhD,GAAM3D,OAAO+E,GAAI4B,IAAcZ,EAC7BV,EAAU1B,GAAOgD,EAAW6D,GAC1B7C,GAA4BvE,EAAcO,GAAOgD,IAEnDtD,EAAwBM,GAAOgD,SAG9B,IAAI8C,KAAcK,EAAsB,CAG7C,GAAaY,IAAoBF,GAC/B7C,GAA4B7C,EAAiBnB,GAAOgD,EAGpD8D,KADEhB,KAAckB,EACGD,GAAoB,EAEpBA,IAMzB/G,GAAM3D,OAAOkF,GAAIyB,KAAe0B,GAAgBoC,GAG5C5C,IACF1B,EAAoBpG,EAAM4D,GAAOgD,GAKvC0B,IAAiBgB,GACjBf,GAAevC,EAAMuC,GAAcc,IACnCb,IAAc,EACdL,GAAYC,GAgBd,GAAII,GAAa,GAAKV,GAAmB,CACvC,GAAa+C,IAAyB7K,EAAKC,OAAO+E,GAAI4B,IAClDgB,GACSkD,GAA2BD,GAAyBvC,GAEpDyC,GAAe,EACfC,GAActD,GAERhE,GAAeD,EAAgBzD,EAC9C0D,MAAiBuH,EACnBD,IAAeF,GACNpH,KAAiBkH,EAC1BI,IAAeF,GAA2B,EACjCpH,KAAiBiG,GACtBkB,GAAyBvC,KAC3ByC,GAAgBD,GAA2BtC,GAI/C,IAAW0C,IAAW,CACtB,KAAK5D,GAAI,EAAGA,GAAIkB,KAAclB,GAAG,CAC/B,GAAW6D,IAAaD,GAGXE,GAAa,CAC1B,KAAK7D,GAAK4D,GAAY5D,GAAKT,IAAcS,GAEvC,GADA3D,GAAQ5D,EAAKU,SAAS6G,IAClB/C,EAAgBZ,MAAWe,GAA/B,CAGA,GAAIf,GAAM2F,YAAcjC,GACtB,KAEGzG,GAAY+C,GAAM3D,OAAO+E,GAAI4B,OAChCwE,GAAapF,EACXoF,GACAxH,GAAM3D,OAAO+E,GAAI4B,IAAcvD,EAAcO,GAAOgD,KAO1D,IAHAsE,GAAW3D,GACX6D,IAAcL,GAETxD,GAAK4D,GAAY5D,GAAK2D,KAAY3D,GAErC,GADA3D,GAAQ5D,EAAKU,SAAS6G,IAClB/C,EAAgBZ,MAAWe,GAA/B,CAIA,GAAmB0G,IAAwB1H,EAAa3D,EAAM4D,GAC9D,IAAIyH,KAA0BtB,EAC5BnG,GAAM3D,OAAOkF,GAAIyB,IAAcoE,GAAc1J,EAAiBsC,GAAOgD,OAChE,IAAIyE,KAA0BJ,EACnCrH,GAAM3D,OAAOkF,GAAIyB,IAAcoE,GAAcI,GAAatJ,EAAkB8B,GAAOgD,GAAahD,GAAM3D,OAAO+E,GAAI4B,QAC5G,IAAIyE,KAA0BT,EAAkB,CACrD,GAAaU,IAAc1H,GAAM3D,OAAO+E,GAAI4B,GAC5ChD,IAAM3D,OAAOkF,GAAIyB,IAAcoE,IAAeI,GAAaE,IAAe,MACjED,MAA0B1B,IACnC/F,GAAM3D,OAAOkF,GAAIyB,IAAcoE,GAAc1J,EAAiBsC,GAAOgD,IAMzEoE,IAAeI,IAInB,GAAYG,KAAuB,EACvBC,IAAwB,CAmCpC,IA/BK3D,KACH7H,EAAKC,OAAO+E,GAAI2B,IAAaX,EAG3BV,EAAUtF,EAAM2G,EAAU4B,GAAepF,EAA4BnD,EAAM2G,IAE3EgB,IAGEhB,IAAazF,GACbyF,IAAatF,IACfkK,IAAuB,IAItBzD,KACH9H,EAAKC,OAAO+E,GAAI4B,IAAcZ,EAI5BV,EAAUtF,EAAM4G,EAAW0B,GAAgBV,IAC3CA,IAGEhB,IAAc1F,GACd0F,IAAcvF,IAChBmK,IAAwB,IAKxBD,IAAwBC,GAC1B,IAAKlE,GAAI,EAAGA,GAAIR,IAAcQ,GAC5B1D,GAAQ5D,EAAKU,SAAS4G,IAElBiE,IACFnF,EAAoBpG,EAAM4D,GAAO+C,GAG/B6E,IACFpF,EAAoBpG,EAAM4D,GAAOgD,EAOvC,KADAqB,GAAuBD,GACS,OAAzBC,IAA+B,CAGpC,IAAKV,GAAK,EAAGA,GAAK,EAAGA,KACnBhG,GAAe,IAAPgG,GAAYtG,EAAyBG,GAExCP,EAAYb,EAAKC,OAAO+E,GAAIzD,QAC5B0D,EAAagD,GAAsB1G,KACpC2D,EAAa+C,GAAsB1B,GAAQhF,MAC3C2D,EAAa+C,GAAsB5B,GAAS9E,OAC9C0G,GAAqBhI,OAAO+E,GAAIzD,KAASyE,EACvCV,EAAU2C,GAAsB1G,GAAMvB,EAAKC,OAAO+E,GAAIzD,KACpD6B,EAAcpD,EAAMuB,IACpB8B,EAAc4E,GAAsB1G,IACpC8D,EAAY4C,GAAsB1B,GAAQhF,KAC1C8D,EAAY4C,GAAsB5B,GAAS9E,MAG7C+B,EAAwB2E,GAAsB1G,MAI9C2D,EAAa+C,GAAsB5B,GAAS9E,OAC3C2D,EAAa+C,GAAsB1B,GAAQhF,OAC9C0G,GAAqBhI,OAAOsG,GAAQhF,KAClCvB,EAAKC,OAAO+E,GAAIzD,KAChB0G,GAAqBhI,OAAO+E,GAAIzD,KAChC8D,EAAY4C,GAAsB5B,GAAS9E,KAIjDqC,IAAQqE,GACRA,GAAuBA,GAAqBuB,kBAC5C5F,GAAM4F,kBAAoB,MAI9B,QAASM,GAAW9J,EAAMyG,EAAgBC,EAAiBvC,GACzDnE,EAAKyL,cAAe,CAEpB,IAAIzH,GAAYhE,EAAKS,MAAMuD,WAAaK,EACpCqH,GACD1L,EAAKE,SACNF,EAAK2L,YACL3L,EAAK2L,WAAWC,kBAAoB5L,EAAKC,OAAOG,QAChDJ,EAAK2L,WAAWE,iBAAmB7L,EAAKC,OAAOE,OAC/CH,EAAK2L,WAAWlF,iBAAmBA,GACnCzG,EAAK2L,WAAWjF,kBAAoBA,GACpC1G,EAAK2L,WAAW3H,YAAcA,CAE5B0H,IACF1L,EAAKC,OAAOE,MAAQH,EAAK2L,WAAWxL,MACpCH,EAAKC,OAAOG,OAASJ,EAAK2L,WAAWvL,OACrCJ,EAAKC,OAAOI,IAAML,EAAK2L,WAAWtL,IAClCL,EAAKC,OAAOK,KAAON,EAAK2L,WAAWrL,OAE9BN,EAAK2L,aACR3L,EAAK2L,eAGP3L,EAAK2L,WAAWE,eAAiB7L,EAAKC,OAAOE,MAC7CH,EAAK2L,WAAWC,gBAAkB5L,EAAKC,OAAOG,OAC9CJ,EAAK2L,WAAWlF,eAAiBA,EACjCzG,EAAK2L,WAAWjF,gBAAkBA,EAClC1G,EAAK2L,WAAW3H,UAAYA,EAG5BhE,EAAKU,SAASrC,QAAQ,SAASuF,GAC7BA,EAAM3D,OAAOE,MAAQ5B,OACrBqF,EAAM3D,OAAOG,OAAS7B,OACtBqF,EAAM3D,OAAOI,IAAM,EACnBuD,EAAM3D,OAAOK,KAAO,IAGtBkG,EAAexG,EAAMyG,EAAgBC,EAAiBvC,GAEtDnE,EAAK2L,WAAWxL,MAAQH,EAAKC,OAAOE,MACpCH,EAAK2L,WAAWvL,OAASJ,EAAKC,OAAOG,OACrCJ,EAAK2L,WAAWtL,IAAML,EAAKC,OAAOI,IAClCL,EAAK2L,WAAWrL,KAAON,EAAKC,OAAOK,MA9qCvC,GAAI4G,GAEA9C,EAAwB,UACxBC,EAAoB,MACpBJ,EAAoB,MAEpBhD,EAAyB,MACzBC,EAAiC,cACjCE,EAA4B,SAC5BC,EAAoC,iBAEpCyH,EAAyB,aACzBC,EAAqB,SACrBuB,EAAuB,WACvBC,EAA4B,gBAC5BC,EAA2B,eAE3BT,EAAuB,aACvBa,EAAmB,SACnBK,EAAqB,WACrBtB,EAAoB,UAEpBhF,GAAwB,WACxBiF,GAAwB,WAExBrD,IACFhB,IAAO,OACPE,cAAe,QACfC,OAAU,MACVE,iBAAkB,UAEhBS,IACFd,IAAO,QACPE,cAAe,OACfC,OAAU,SACVE,iBAAkB,OAEhBT,IACFI,IAAO,OACPE,cAAe,QACfC,OAAU,MACVE,iBAAkB,UAEhBZ,IACFO,IAAO,QACPE,cAAe,QACfC,OAAU,SACVE,iBAAkB,SAmoCpB,QACEY,eAAgBA,EAChB1G,cAAegK,EACf/J,UAAWA,KAYb,OALqB,gBAAZH,WACTC,OAAOD,QAAUE,GAIV,SAASE,GAGdF,EAAcC,UAAUC,GACxBF,EAAcA,cAAcE,OAK/B/B,OAAO6N,kBAAoB7N,OAAO8N,aAAe,WAChDC,OAAO5N,UAAU0N,iBAAmBG,aAAa7N,UAAU0N,iBAAmBI,QAAQ9N,UAAU0N,iBAAmB,SAA0BK,EAAMC,GACjJ5N,KAAKuN,YAAY,KAAOI,EAAMC,IAGhCJ,OAAO5N,UAAUiO,oBAAsBJ,aAAa7N,UAAUiO,oBAAsBH,QAAQ9N,UAAUiO,oBAAsB,SAA6BF,EAAMC,GAC7J5N,KAAK8N,YAAY,KAAOH,EAAMC,OAIlClO,YAAYqO,OAAS,WACnB,GAAIvM,GAAOwM,SAASC,cAAc,IAElC,KAGE,MAFAzM,GAAKS,MAAMiM,QAAU,OAES,SAAvB1M,EAAKS,MAAMiM,QAClB,MAAOC,GACP,OAAO,KAINzO,YAAYqO,UAAYC,SAAST,aAAeS,SAASI,gBAAgBC,cAC5EL,SAAST,YAAY,qBAAsB,WACzC7N,YAAY4O,UACVC,OAAQP,SAASI,oBAKvB1O,YAAY8O,KAAO,SAAchN,GAE/B,GAAIiN,GAAUjN,EAAKkN,gBAenB,OAZKD,KACHA,EAAUjN,EAAKkN,kBACblN,KAAUA,EACVS,SACAC,cAKJuM,EAAQxM,MAAMiM,QAAU1M,EAAK6M,aAAa,gBAAkB7M,EAAK6M,aAAaH,QAGvEO,EAIT,IAKIE,GALAC,EAAS,IACTC,EAAoB,GACpBC,EAAmBd,SAASI,gBAC5BW,EAAiB,EACjBC,EAAkB,CAGtBtP,aAAY4O,SAAW,SAAgBW,GAErC,GAAIH,EAAiBI,cAAgBH,GAAkBD,EAAiBK,eAAiBH,EAAiB,CAExGD,EAAiBD,EAAiBI,YAClCF,EAAkBF,EAAiBK,aAGnCC,aAAaT,GAGblP,OAAOoO,oBAAoB,SAAUnO,YAAY4O,SAGjD,IAAIC,GAASU,EAAMV,QAAoC,IAA1BU,EAAMV,OAAOc,SAAiBJ,EAAMV,OAASP,SAASI,eAGnF1O,aAAY4P,KAAKf,GAGjBI,EAAUY,WAAW,WACnB9P,OAAO6N,iBAAiB,SAAU5N,YAAY4O,WAC7CM,EAASC,IAIhB,IAAIW,IACFtK,cACEuK,QAAS,UACTC,MAAS,oEAEXpK,YACEmK,QAAS,UACTC,MAAS,mDAEXC,WACEF,QAAS,cACTC,MAAO,8BAETlN,eACEiN,QAAS,MACTC,MAAS,6CAEXpJ,UACEmJ,QAAS,SACTC,MAAS,gCAEX1K,gBACEyK,QAAS,aACTC,MAAS,6DAIbhQ,aAAYkQ,yBAA2B,SAAkCnB,GAEvE,GAAIxM,GAASwM,EAAQxM,MACjB4N,EAASpB,EAAQjN,KAAK6M,aACtByB,EAASrB,EAAQjN,KAAKS,MACtB8N,MAGHF,EAAO,cAAgBC,EAAO,cAAgB,IAAIE,QAAQ,0EAA2E,SAAUC,EAAIzN,EAAe8D,GACjKyJ,EAAOvN,cAAgBA,EACvBuN,EAAOzJ,SAAWA,GAIpB,KAAK,GAAI4J,KAAOV,GAA+B,CAC7C,GAAIW,GAAWD,EAAIF,QAAQ,SAAU,OAAOI,cACxCC,EAAWb,EAA8BU,GACzCI,EAAWT,EAAOM,IAAaL,EAAOK,EAE1ClO,GAAMiO,GAAOG,EAASX,MAAMa,KAAKD,GAAYA,EAAWP,EAAOG,IAAQG,EAASZ,SAIpF,IAAIe,IACFnL,WACEoK,QAAS,OACTC,MAAS,wDAEXC,WACEF,QAAS,cACTC,MAAO,8BAETe,WACEhB,QAAS,OACTC,MAAS,iJAEXgB,UACEjB,QAAS,EACTC,MAAS,wBAEXiB,YACElB,QAAS,EACTC,MAAS,wBAEXkB,OACEnB,QAAS,EACTC,MAAS,mBAIbhQ,aAAYmR,oBAAsB,SAA6BpC,GAE7D,GAAIxM,GAASwM,EAAQxM,MACjB4N,EAASpB,EAAQjN,KAAK6M,aACtByB,EAASrB,EAAQjN,KAAKS,MACtB8N,MAGHF,EAAOzJ,MAAQ0J,EAAO1J,MAAQ,IAAI4J,QAAQ,sBAAuB,SAAUC,GAC1EF,EAAOW,SAAWT,GAIpB,KAAK,GAAIC,KAAOM,GAA0B,CACxC,GAAIL,GAAWD,EAAIF,QAAQ,SAAU,OAAOI,cACxCC,EAAWG,EAAyBN,GACpCI,EAAWT,EAAOM,IAAaL,EAAOK,EAE1ClO,GAAMiO,GAAOG,EAASX,MAAMa,KAAKD,GAAYA,EAAWP,EAAOG,IAAQG,EAASZ,QAEhD,gBAArBY,GAASZ,UAClBxN,EAAMiO,GAAOY,WAAW7O,EAAMiO,MAKpC,IAAIa,GAAiB,gMAEjBC,GACFC,OAAQ,EACRC,KAAQ,EACRC,MAAQ,EACRC,KAAQ,GAGNC,GACF/M,kBAAmB,EACnBH,gBAAiB,EACjBC,iBAAkB,EAClBC,eAAgB,EAChBzC,OAAQ,EACRiC,cAAe,EACfH,YAAa,EACbC,aAAc,EACdC,WAAY,EACZR,aAAc,EACdH,WAAY,EACZC,YAAa,EACbC,UAAW,EACXmE,UAAW,EACXD,SAAU,EACVF,UAAW,EACXH,SAAU,EACVrF,MAAO,GAGL2P,EAAmB,iCAEnBC,EAAkB,GAEtB7R,aAAY8R,kBAAoB,SAA2B/C,GAEzD,GAKIgD,GACAC,EACAC,EAPAnQ,EAAOiN,EAAQjN,KACfS,EAAQwM,EAAQxM,MAGhB2P,EAAcpQ,EAAKoQ,WAMnBC,EAAS7D,SAASC,cAAc,KAEhC6D,EAASD,EAAOE,aAEhBlC,EAASrO,EAAK6M,YAElByD,GAAOE,QAAUjB,EAAiB,aAAelB,EAAOoC,SAGxDL,EAAWM,aAAaL,EAAQrQ,EAAK2Q,aAErClQ,EAAMgQ,SAAWJ,EAAOO,YAExBN,EAAOG,SAAWhQ,EAAMgQ,SAAW,IAEnC,KAAK,GAAI/B,KAAOmB,GAAa,CAC3B,GAAIf,GAAWT,EAAOK,EAGlBoB,GAAiBf,KAAKD,IAA0B,SAAbA,IAAwB,kBAAkBC,KAAKL,GAEhF,KAAKK,KAAKD,IAER,wBAAwBC,KAAKL,IAC1BwB,IACHA,EAAeE,EAAWS,cAG5BV,EAAeD,IAEVD,IACHA,EAAcG,EAAWQ,aAG3BT,EAAeF,GAGjBxP,EAAMiO,GAAOY,WAAWR,GAAYqB,EAAeJ,IAEnDO,EAAOnQ,MAAQ2O,EAEfrO,EAAMiO,GAAO2B,EAAOO,aAEb,UAAU7B,KAAKL,IAAQI,IAAYU,GAC5C/O,EAAMiO,GAAOc,EAAkBV,SAExBrO,GAAMiO,GAKjB0B,EAAWU,YAAYT,GAGU,SAA7BhC,EAAO0C,iBACTtQ,EAAMoC,eAAoB,GAGK,SAA7BwL,EAAO2C,mBACTvQ,EAAMmC,iBAAoB,GAGK,SAA7ByL,EAAO4C,oBACTxQ,EAAMqC,kBAAoB,GAGK,SAA7BuL,EAAO6C,kBACTzQ,EAAMkC,gBAAoB,GAIvBlC,EAAMN,OAAUM,EAAM+E,WACrB,OAAOuJ,KAAKtO,EAAMiM,SACpBjM,EAAMN,MAAQH,EAAK4Q,YAEnBnQ,EAAM+E,SAAWxF,EAAK4Q,aAKrBnQ,EAAML,QAAWK,EAAMkF,WACrB,OAAOoJ,KAAKtO,EAAMiM,WACrBjM,EAAMkF,UAAY3F,EAAK6Q,eAK7B3S,YAAY4P,KAAO,SAAc9N,GAE/B,GAAIiN,GAAU/O,YAAY8O,KAAKhN,GAG3BS,EAAUwM,EAAQxM,MAClBiM,EAAUjM,EAAMiM,OAGpB,IAAgB,SAAZA,EACF,QAIF,IAAIhI,GAAUgI,EAAQyE,MAAM,kBA2C5B,IAxCIzM,IACFxG,YAAYkQ,yBAAyBnB,GAErCjN,EAAKuQ,aAAaC,QAAU,YAAc9L,EAAO,GAAK,eAAiB,SAEvEuI,EAAQvM,aAIVvC,MAAMC,UAAUC,QAAQkB,KAAKS,EAAKoR,WAAY,SAAUC,EAAWC,GAEjE,GAA2B,IAAvBD,EAAUxD,SAAgB,CAE5B,GAAI0D,GAAerT,YAAY4P,KAAKuD,GAChCG,EAAeD,EAAa9Q,KAEhC8Q,GAAajS,MAAQgS,EAGjB5M,IAEFxG,YAAYmR,oBAAoBkC,GAGH,SAAzBC,EAAW3N,YACb2N,EAAW3N,UAAYpD,EAAMqD,YAG/B0N,EAAW5M,KAAO4M,EAAWtC,SAG7BmC,EAAUd,aAAaC,QAAU,uBAGjCvD,EAAQvM,SAAS+Q,KAAKF,OAMxB7M,EAAQ,CAEVuI,EAAQvM,SAASrC,QAAQ,SAAUuF,GACjC1F,YAAY8R,kBAAkBpM,KAIhCqJ,EAAQvM,SAASgR,KAAK,SAAUC,EAAQC,GACtC,MAAOD,GAAOlR,MAAM2O,MAAQwC,EAAOnR,MAAM2O,OAASuC,EAAOrS,MAAQsS,EAAOtS,QAItE,YAAYyP,KAAKtO,EAAMO,iBAEzBiM,EAAQvM,SAASmR,UAGjBpR,EAAMO,cAAgBP,EAAMO,cAAcwN,QAAQ,YAAa,IAGlC,eAAzB/N,EAAM+C,eACR/C,EAAM+C,eAAiB,WACW,aAAzB/C,EAAM+C,iBACf/C,EAAM+C,eAAiB,eAK3BtF,YAAY8R,kBAAkB/C,SAGvBA,GAAQtB,iBACRsB,GAAQhN,MAGf,IAAI4C,GAAiBpC,EAAMoC,eACvBC,EAAoBrC,EAAMqC,iBAE9BrC,GAAMoC,eAAiB,EACvBpC,EAAMqC,kBAAoB,EAC1BrC,EAAMkC,gBAAkB,EAEI,WAAxBlC,EAAMO,gBACRP,EAAMN,OAASM,EAAMmC,kBAIvB1E,YAAY4B,cAAcmN,GAG1BjN,EAAKuQ,aAAaC,QAAU,gEAAkEvD,EAAQhN,OAAOE,MAAQM,EAAMmC,kBAAoB,cAAgBqK,EAAQhN,OAAOG,OAASyC,EAAiBC,GAAqB,IAG7N,IAAIgP,MACAC,EAAW,EAEXC,EAAgC,WAAxBvR,EAAMO,cAA6B,QAAU,QAEzDiM,GAAQvM,SAASrC,QAAQ,SAAUuF,GACjCkO,EAAUlO,EAAM2F,WAAapK,KAAKC,IAAI0S,EAAUlO,EAAM2F,YAAc,EAAG3F,EAAM3D,OAAO+R,IAEpFD,EAAW5S,KAAKC,IAAI2S,EAAUnO,EAAM2F,UAAY,KAIlD0D,EAAQvM,SAASrC,QAAQ,SAAUuF,GACjC,GAAI3D,GAAS2D,EAAM3D,MAEW,aAA1B2D,EAAMnD,MAAMoD,YACd5D,EAAO+R,GAASF,EAAUlO,EAAM2F,YAGlC3F,EAAM5D,KAAKuQ,aAAaC,QAAU,wEAA0EvQ,EAAOE,MAAQ,aAAeF,EAAOG,OAAS,UAAYH,EAAOI,IAAM,WAAaJ,EAAOK,KAAO,OAIlN,MAAO2M","file":"rocketbelt.flexibility.min.js","sourcesContent":["/*! Flexibility 1.0.6 | MIT Licensed | github.com/10up/flexibility */\n(function () {\n  window.flexibility = {};\n\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function forEach(callback) {\n      if (this === undefined || this === null) {\n        throw new TypeError(this + 'is not an object');\n      }\n\n      if (!(callback instanceof Function)) {\n        throw new TypeError(callback + ' is not a function');\n      }\n\n      var object = Object(this);\n      var scope = arguments[1];\n      var arraylike = object instanceof String ? object.split('') : object;\n      var length = Math.max(Math.min(arraylike.length, 9007199254740991), 0) || 0;\n      var index = -1;\n\n      while (++index < length) {\n        if (index in arraylike) {\n          callback.call(scope, arraylike[index], index, object);\n        }\n      }\n    };\n  }\n\n  // UMD (Universal Module Definition)\n  // See https://github.com/umdjs/umd for reference\n  //\n  // This file uses the following specific UMD implementation:\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      // AMD. Register as an anonymous module.\n      define([], factory);\n    } else if (typeof exports === 'object') {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    } else {\n      // Browser globals (root is window)\n      root.computeLayout = factory();\n    }\n  }(flexibility, function() {\n    /**\n   * Copyright (c) 2014, Facebook, Inc.\n   * All rights reserved.\n   *\n   * This source code is licensed under the BSD-style license found in the\n   * LICENSE file in the root directory of this source tree. An additional grant\n   * of patent rights can be found in the PATENTS file in the same directory.\n   */\n\n  var computeLayout = (function() {\n\n    var CSS_UNDEFINED;\n\n    var CSS_DIRECTION_INHERIT = 'inherit';\n    var CSS_DIRECTION_LTR = 'ltr';\n    var CSS_DIRECTION_RTL = 'rtl';\n\n    var CSS_FLEX_DIRECTION_ROW = 'row';\n    var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n    var CSS_FLEX_DIRECTION_COLUMN = 'column';\n    var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n    var CSS_JUSTIFY_FLEX_START = 'flex-start';\n    var CSS_JUSTIFY_CENTER = 'center';\n    var CSS_JUSTIFY_FLEX_END = 'flex-end';\n    var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n    var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n    var CSS_ALIGN_FLEX_START = 'flex-start';\n    var CSS_ALIGN_CENTER = 'center';\n    var CSS_ALIGN_FLEX_END = 'flex-end';\n    var CSS_ALIGN_STRETCH = 'stretch';\n\n    var CSS_POSITION_RELATIVE = 'relative';\n    var CSS_POSITION_ABSOLUTE = 'absolute';\n\n    var leading = {\n      'row': 'left',\n      'row-reverse': 'right',\n      'column': 'top',\n      'column-reverse': 'bottom'\n    };\n    var trailing = {\n      'row': 'right',\n      'row-reverse': 'left',\n      'column': 'bottom',\n      'column-reverse': 'top'\n    };\n    var pos = {\n      'row': 'left',\n      'row-reverse': 'right',\n      'column': 'top',\n      'column-reverse': 'bottom'\n    };\n    var dim = {\n      'row': 'width',\n      'row-reverse': 'width',\n      'column': 'height',\n      'column-reverse': 'height'\n    };\n\n    // When transpiled to Java / C the node type has layout, children and style\n    // properties. For the JavaScript version this function adds these properties\n    // if they don't already exist.\n    function fillNodes(node) {\n      if (!node.layout || node.isDirty) {\n        node.layout = {\n          width: undefined,\n          height: undefined,\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      if (!node.style) {\n        node.style = {};\n      }\n\n      if (!node.children) {\n        node.children = [];\n      }\n\n      if (node.style.measure && node.children && node.children.length) {\n        throw new Error('Using custom measure function is supported only for leaf nodes.');\n      }\n\n      node.children.forEach(fillNodes);\n      return node;\n    }\n\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    function isRowDirection(flexDirection) {\n      return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n             flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n    }\n\n    function isColumnDirection(flexDirection) {\n      return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n             flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n    }\n\n    function getLeadingMargin(node, axis) {\n      if (node.style.marginStart !== undefined && isRowDirection(axis)) {\n        return node.style.marginStart;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.marginLeft;   break;\n        case 'row-reverse':    value = node.style.marginRight;  break;\n        case 'column':         value = node.style.marginTop;    break;\n        case 'column-reverse': value = node.style.marginBottom; break;\n      }\n\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (node.style.margin !== undefined) {\n        return node.style.margin;\n      }\n\n      return 0;\n    }\n\n    function getTrailingMargin(node, axis) {\n      if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n        return node.style.marginEnd;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.marginRight;  break;\n        case 'row-reverse':    value = node.style.marginLeft;   break;\n        case 'column':         value = node.style.marginBottom; break;\n        case 'column-reverse': value = node.style.marginTop;    break;\n      }\n\n      if (value != null) {\n        return value;\n      }\n\n      if (node.style.margin !== undefined) {\n        return node.style.margin;\n      }\n\n      return 0;\n    }\n\n    function getLeadingPadding(node, axis) {\n      if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n          && isRowDirection(axis)) {\n        return node.style.paddingStart;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.paddingLeft;   break;\n        case 'row-reverse':    value = node.style.paddingRight;  break;\n        case 'column':         value = node.style.paddingTop;    break;\n        case 'column-reverse': value = node.style.paddingBottom; break;\n      }\n\n      if (value != null && value >= 0) {\n        return value;\n      }\n\n      if (node.style.padding !== undefined && node.style.padding >= 0) {\n        return node.style.padding;\n      }\n\n      return 0;\n    }\n\n    function getTrailingPadding(node, axis) {\n      if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n          && isRowDirection(axis)) {\n        return node.style.paddingEnd;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.paddingRight;  break;\n        case 'row-reverse':    value = node.style.paddingLeft;   break;\n        case 'column':         value = node.style.paddingBottom; break;\n        case 'column-reverse': value = node.style.paddingTop;    break;\n      }\n\n      if (value != null && value >= 0) {\n        return value;\n      }\n\n      if (node.style.padding !== undefined && node.style.padding >= 0) {\n        return node.style.padding;\n      }\n\n      return 0;\n    }\n\n    function getLeadingBorder(node, axis) {\n      if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n          && isRowDirection(axis)) {\n        return node.style.borderStartWidth;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.borderLeftWidth;   break;\n        case 'row-reverse':    value = node.style.borderRightWidth;  break;\n        case 'column':         value = node.style.borderTopWidth;    break;\n        case 'column-reverse': value = node.style.borderBottomWidth; break;\n      }\n\n      if (value != null && value >= 0) {\n        return value;\n      }\n\n      if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n        return node.style.borderWidth;\n      }\n\n      return 0;\n    }\n\n    function getTrailingBorder(node, axis) {\n      if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n          && isRowDirection(axis)) {\n        return node.style.borderEndWidth;\n      }\n\n      var value = null;\n      switch (axis) {\n        case 'row':            value = node.style.borderRightWidth;  break;\n        case 'row-reverse':    value = node.style.borderLeftWidth;   break;\n        case 'column':         value = node.style.borderBottomWidth; break;\n        case 'column-reverse': value = node.style.borderTopWidth;    break;\n      }\n\n      if (value != null && value >= 0) {\n        return value;\n      }\n\n      if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n        return node.style.borderWidth;\n      }\n\n      return 0;\n    }\n\n    function getLeadingPaddingAndBorder(node, axis) {\n      return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n    }\n\n    function getTrailingPaddingAndBorder(node, axis) {\n      return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n    }\n\n    function getBorderAxis(node, axis) {\n      return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n    }\n\n    function getMarginAxis(node, axis) {\n      return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n    }\n\n    function getPaddingAndBorderAxis(node, axis) {\n      return getLeadingPaddingAndBorder(node, axis) +\n          getTrailingPaddingAndBorder(node, axis);\n    }\n\n    function getJustifyContent(node) {\n      if (node.style.justifyContent) {\n        return node.style.justifyContent;\n      }\n      return 'flex-start';\n    }\n\n    function getAlignContent(node) {\n      if (node.style.alignContent) {\n        return node.style.alignContent;\n      }\n      return 'flex-start';\n    }\n\n    function getAlignItem(node, child) {\n      if (child.style.alignSelf) {\n        return child.style.alignSelf;\n      }\n      if (node.style.alignItems) {\n        return node.style.alignItems;\n      }\n      return 'stretch';\n    }\n\n    function resolveAxis(axis, direction) {\n      if (direction === CSS_DIRECTION_RTL) {\n        if (axis === CSS_FLEX_DIRECTION_ROW) {\n          return CSS_FLEX_DIRECTION_ROW_REVERSE;\n        } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n          return CSS_FLEX_DIRECTION_ROW;\n        }\n      }\n\n      return axis;\n    }\n\n    function resolveDirection(node, parentDirection) {\n      var direction;\n      if (node.style.direction) {\n        direction = node.style.direction;\n      } else {\n        direction = CSS_DIRECTION_INHERIT;\n      }\n\n      if (direction === CSS_DIRECTION_INHERIT) {\n        direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n      }\n\n      return direction;\n    }\n\n    function getFlexDirection(node) {\n      if (node.style.flexDirection) {\n        return node.style.flexDirection;\n      }\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n\n    function getCrossFlexDirection(flexDirection, direction) {\n      if (isColumnDirection(flexDirection)) {\n        return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n      } else {\n        return CSS_FLEX_DIRECTION_COLUMN;\n      }\n    }\n\n    function getPositionType(node) {\n      if (node.style.position) {\n        return node.style.position;\n      }\n      return 'relative';\n    }\n\n    function isFlex(node) {\n      return (\n        getPositionType(node) === CSS_POSITION_RELATIVE &&\n        node.style.flex > 0\n      );\n    }\n\n    function isFlexWrap(node) {\n      return node.style.flexWrap === 'wrap';\n    }\n\n    function getDimWithMargin(node, axis) {\n      return node.layout[dim[axis]] + getMarginAxis(node, axis);\n    }\n\n    function isDimDefined(node, axis) {\n      return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n    }\n\n    function isPosDefined(node, pos) {\n      return node.style[pos] !== undefined;\n    }\n\n    function isMeasureDefined(node) {\n      return node.style.measure !== undefined;\n    }\n\n    function getPosition(node, pos) {\n      if (node.style[pos] !== undefined) {\n        return node.style[pos];\n      }\n      return 0;\n    }\n\n    function boundAxis(node, axis, value) {\n      var min = {\n        'row': node.style.minWidth,\n        'row-reverse': node.style.minWidth,\n        'column': node.style.minHeight,\n        'column-reverse': node.style.minHeight\n      }[axis];\n\n      var max = {\n        'row': node.style.maxWidth,\n        'row-reverse': node.style.maxWidth,\n        'column': node.style.maxHeight,\n        'column-reverse': node.style.maxHeight\n      }[axis];\n\n      var boundValue = value;\n      if (max !== undefined && max >= 0 && boundValue > max) {\n        boundValue = max;\n      }\n      if (min !== undefined && min >= 0 && boundValue < min) {\n        boundValue = min;\n      }\n      return boundValue;\n    }\n\n    function fmaxf(a, b) {\n      if (a > b) {\n        return a;\n      }\n      return b;\n    }\n\n    // When the user specifically sets a value for width or height\n    function setDimensionFromStyle(node, axis) {\n      // The parent already computed us a width or height. We just skip it\n      if (node.layout[dim[axis]] !== undefined) {\n        return;\n      }\n      // We only run if there's a width or height defined\n      if (!isDimDefined(node, axis)) {\n        return;\n      }\n\n      // The dimensions can never be smaller than the padding and border\n      node.layout[dim[axis]] = fmaxf(\n        boundAxis(node, axis, node.style[dim[axis]]),\n        getPaddingAndBorderAxis(node, axis)\n      );\n    }\n\n    function setTrailingPosition(node, child, axis) {\n      child.layout[trailing[axis]] = node.layout[dim[axis]] -\n          child.layout[dim[axis]] - child.layout[pos[axis]];\n    }\n\n    // If both left and right are defined, then use left. Otherwise return\n    // +left or -right depending on which is defined.\n    function getRelativePosition(node, axis) {\n      if (node.style[leading[axis]] !== undefined) {\n        return getPosition(node, leading[axis]);\n      }\n      return -getPosition(node, trailing[axis]);\n    }\n\n    function layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, /*css_direction_t*/parentDirection) {\n      var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n      var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n      var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n      var/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n      // Handle width and height style attributes\n      setDimensionFromStyle(node, mainAxis);\n      setDimensionFromStyle(node, crossAxis);\n\n      // Set the resolved resolution in the node's layout\n      node.layout.direction = direction;\n\n      // The position is set by the parent, but we need to complete it with a\n      // delta composed of the margin and left/top/right/bottom\n      node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n        getRelativePosition(node, mainAxis);\n      node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n        getRelativePosition(node, mainAxis);\n      node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n        getRelativePosition(node, crossAxis);\n      node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n        getRelativePosition(node, crossAxis);\n\n      // Inline immutable values from the target node to avoid excessive method\n      // invocations during the layout calculation.\n      var/*int*/ childCount = node.children.length;\n      var/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\n      var/*float*/ paddingAndBorderAxisColumn = getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n      if (isMeasureDefined(node)) {\n        var/*bool*/ isResolvedRowDimDefined = !isUndefined(node.layout[dim[resolvedRowAxis]]);\n\n        var/*float*/ width = CSS_UNDEFINED;\n        if (isDimDefined(node, resolvedRowAxis)) {\n          width = node.style.width;\n        } else if (isResolvedRowDimDefined) {\n          width = node.layout[dim[resolvedRowAxis]];\n        } else {\n          width = parentMaxWidth -\n            getMarginAxis(node, resolvedRowAxis);\n        }\n        width -= paddingAndBorderAxisResolvedRow;\n\n        var/*float*/ height = CSS_UNDEFINED;\n        if (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n          height = node.style.height;\n        } else if (!isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]])) {\n          height = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]];\n        } else {\n          height = parentMaxHeight -\n            getMarginAxis(node, resolvedRowAxis);\n        }\n        height -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n        // We only need to give a dimension for the text if we haven't got any\n        // for it computed yet. It can either be from the style attribute or because\n        // the element is flexible.\n        var/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\n        var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n          isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n        // Let's not measure the text if we already know both dimensions\n        if (isRowUndefined || isColumnUndefined) {\n          var/*css_dim_t*/ measureDim = node.style.measure(\n            /*(c)!node->context,*/\n            /*(java)!layoutContext.measureOutput,*/\n            width,\n            height\n          );\n          if (isRowUndefined) {\n            node.layout.width = measureDim.width +\n              paddingAndBorderAxisResolvedRow;\n          }\n          if (isColumnUndefined) {\n            node.layout.height = measureDim.height +\n              paddingAndBorderAxisColumn;\n          }\n        }\n        if (childCount === 0) {\n          return;\n        }\n      }\n\n      var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n      var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n\n      var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n      var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n      var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n      var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n      var/*bool*/ isMainDimDefined = !isUndefined(node.layout[dim[mainAxis]]);\n      var/*bool*/ isCrossDimDefined = !isUndefined(node.layout[dim[crossAxis]]);\n      var/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\n\n      var/*int*/ i;\n      var/*int*/ ii;\n      var/*css_node_t**/ child;\n      var/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\n\n      var/*css_node_t**/ firstAbsoluteChild = null;\n      var/*css_node_t**/ currentAbsoluteChild = null;\n\n      var/*float*/ definedMainDim = CSS_UNDEFINED;\n      if (isMainDimDefined) {\n        definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\n      }\n\n      // We want to execute the next two loops one per line with flex-wrap\n      var/*int*/ startLine = 0;\n      var/*int*/ endLine = 0;\n      // var/*int*/ nextOffset = 0;\n      var/*int*/ alreadyComputedNextLayout = 0;\n      // We aggregate the total dimensions of the container in those two variables\n      var/*float*/ linesCrossDim = 0;\n      var/*float*/ linesMainDim = 0;\n      var/*int*/ linesCount = 0;\n      while (endLine < childCount) {\n        // <Loop A> Layout non flexible children and count children by type\n\n        // mainContentDim is accumulation of the dimensions and margin of all the\n        // non flexible children. This will be used in order to either set the\n        // dimensions of the node if none already exist, or to compute the\n        // remaining space left for the flexible children.\n        var/*float*/ mainContentDim = 0;\n\n        // There are three kind of children, non flexible, flexible and absolute.\n        // We need to know how many there are in order to distribute the space.\n        var/*int*/ flexibleChildrenCount = 0;\n        var/*float*/ totalFlexible = 0;\n        var/*int*/ nonFlexibleChildrenCount = 0;\n\n        // Use the line loop to position children in the main axis for as long\n        // as they are using a simple stacking behaviour. Children that are\n        // immediately stacked in the initial loop will not be touched again\n        // in <Loop C>.\n        var/*bool*/ isSimpleStackMain =\n            (isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\n            (!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\n        var/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\n\n        // Use the initial line loop to position children in the cross axis for\n        // as long as they are relatively positioned with alignment STRETCH or\n        // FLEX_START. Children that are immediately stacked in the initial loop\n        // will not be touched again in <Loop D>.\n        var/*bool*/ isSimpleStackCross = true;\n        var/*int*/ firstComplexCross = childCount;\n\n        var/*css_node_t**/ firstFlexChild = null;\n        var/*css_node_t**/ currentFlexChild = null;\n\n        var/*float*/ mainDim = leadingPaddingAndBorderMain;\n        var/*float*/ crossDim = 0;\n\n        var/*float*/ maxWidth;\n        var/*float*/ maxHeight;\n        for (i = startLine; i < childCount; ++i) {\n          child = node.children[i];\n          child.lineIndex = linesCount;\n\n          child.nextAbsoluteChild = null;\n          child.nextFlexChild = null;\n\n          var/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n          // Pre-fill cross axis dimensions when the child is using stretch before\n          // we call the recursive layout pass\n          if (alignItem === CSS_ALIGN_STRETCH &&\n              getPositionType(child) === CSS_POSITION_RELATIVE &&\n              isCrossDimDefined &&\n              !isDimDefined(child, crossAxis)) {\n            child.layout[dim[crossAxis]] = fmaxf(\n              boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n                paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, crossAxis)\n            );\n          } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n            // Store a private linked list of absolutely positioned children\n            // so that we can efficiently traverse them later.\n            if (firstAbsoluteChild === null) {\n              firstAbsoluteChild = child;\n            }\n            if (currentAbsoluteChild !== null) {\n              currentAbsoluteChild.nextAbsoluteChild = child;\n            }\n            currentAbsoluteChild = child;\n\n            // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n            // left and right or top and bottom).\n            for (ii = 0; ii < 2; ii++) {\n              axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n              if (!isUndefined(node.layout[dim[axis]]) &&\n                  !isDimDefined(child, axis) &&\n                  isPosDefined(child, leading[axis]) &&\n                  isPosDefined(child, trailing[axis])) {\n                child.layout[dim[axis]] = fmaxf(\n                  boundAxis(child, axis, node.layout[dim[axis]] -\n                    getPaddingAndBorderAxis(node, axis) -\n                    getMarginAxis(child, axis) -\n                    getPosition(child, leading[axis]) -\n                    getPosition(child, trailing[axis])),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, axis)\n                );\n              }\n            }\n          }\n\n          var/*float*/ nextContentDim = 0;\n\n          // It only makes sense to consider a child flexible if we have a computed\n          // dimension for the node.\n          if (isMainDimDefined && isFlex(child)) {\n            flexibleChildrenCount++;\n            totalFlexible += child.style.flex;\n\n            // Store a private linked list of flexible children so that we can\n            // efficiently traverse them later.\n            if (firstFlexChild === null) {\n              firstFlexChild = child;\n            }\n            if (currentFlexChild !== null) {\n              currentFlexChild.nextFlexChild = child;\n            }\n            currentFlexChild = child;\n\n            // Even if we don't know its exact size yet, we already know the padding,\n            // border and margin. We'll use this partial information, which represents\n            // the smallest possible size for the child, to compute the remaining\n            // available space.\n            nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n              getMarginAxis(child, mainAxis);\n\n          } else {\n            maxWidth = CSS_UNDEFINED;\n            maxHeight = CSS_UNDEFINED;\n\n            if (!isMainRowDirection) {\n              if (isDimDefined(node, resolvedRowAxis)) {\n                maxWidth = node.layout[dim[resolvedRowAxis]] -\n                  paddingAndBorderAxisResolvedRow;\n              } else {\n                maxWidth = parentMaxWidth -\n                  getMarginAxis(node, resolvedRowAxis) -\n                  paddingAndBorderAxisResolvedRow;\n              }\n            } else {\n              if (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n                maxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n                    paddingAndBorderAxisColumn;\n              } else {\n                maxHeight = parentMaxHeight -\n                  getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n                  paddingAndBorderAxisColumn;\n              }\n            }\n\n            // This is the main recursive call. We layout non flexible children.\n            if (alreadyComputedNextLayout === 0) {\n              layoutNode(/*(java)!layoutContext, */child, maxWidth, maxHeight, direction);\n            }\n\n            // Absolute positioned elements do not take part of the layout, so we\n            // don't use them to compute mainContentDim\n            if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n              nonFlexibleChildrenCount++;\n              // At this point we know the final size and margin of the element.\n              nextContentDim = getDimWithMargin(child, mainAxis);\n            }\n          }\n\n          // The element we are about to add would make us go to the next line\n          if (isNodeFlexWrap &&\n              isMainDimDefined &&\n              mainContentDim + nextContentDim > definedMainDim &&\n              // If there's only one element, then it's bigger than the content\n              // and needs its own line\n              i !== startLine) {\n            nonFlexibleChildrenCount--;\n            alreadyComputedNextLayout = 1;\n            break;\n          }\n\n          // Disable simple stacking in the main axis for the current line as\n          // we found a non-trivial child. The remaining children will be laid out\n          // in <Loop C>.\n          if (isSimpleStackMain &&\n              (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\n            isSimpleStackMain = false;\n            firstComplexMain = i;\n          }\n\n          // Disable simple stacking in the cross axis for the current line as\n          // we found a non-trivial child. The remaining children will be laid out\n          // in <Loop D>.\n          if (isSimpleStackCross &&\n              (getPositionType(child) !== CSS_POSITION_RELATIVE ||\n                  (alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\n                  isUndefined(child.layout[dim[crossAxis]]))) {\n            isSimpleStackCross = false;\n            firstComplexCross = i;\n          }\n\n          if (isSimpleStackMain) {\n            child.layout[pos[mainAxis]] += mainDim;\n            if (isMainDimDefined) {\n              setTrailingPosition(node, child, mainAxis);\n            }\n\n            mainDim += getDimWithMargin(child, mainAxis);\n            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n          }\n\n          if (isSimpleStackCross) {\n            child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\n            if (isCrossDimDefined) {\n              setTrailingPosition(node, child, crossAxis);\n            }\n          }\n\n          alreadyComputedNextLayout = 0;\n          mainContentDim += nextContentDim;\n          endLine = i + 1;\n        }\n\n        // <Loop B> Layout flexible children and allocate empty space\n\n        // In order to position the elements in the main axis, we have two\n        // controls. The space between the beginning and the first element\n        // and the space between each two elements.\n        var/*float*/ leadingMainDim = 0;\n        var/*float*/ betweenMainDim = 0;\n\n        // The remaining available space that needs to be allocated\n        var/*float*/ remainingMainDim = 0;\n        if (isMainDimDefined) {\n          remainingMainDim = definedMainDim - mainContentDim;\n        } else {\n          remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n        }\n\n        // If there are flexible children in the mix, they are going to fill the\n        // remaining space\n        if (flexibleChildrenCount !== 0) {\n          var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n          var/*float*/ baseMainDim;\n          var/*float*/ boundMainDim;\n\n          // If the flex share of remaining space doesn't meet min/max bounds,\n          // remove this child from flex calculations.\n          currentFlexChild = firstFlexChild;\n          while (currentFlexChild !== null) {\n            baseMainDim = flexibleMainDim * currentFlexChild.style.flex +\n                getPaddingAndBorderAxis(currentFlexChild, mainAxis);\n            boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\n\n            if (baseMainDim !== boundMainDim) {\n              remainingMainDim -= boundMainDim;\n              totalFlexible -= currentFlexChild.style.flex;\n            }\n\n            currentFlexChild = currentFlexChild.nextFlexChild;\n          }\n          flexibleMainDim = remainingMainDim / totalFlexible;\n\n          // The non flexible children can overflow the container, in this case\n          // we should just assume that there is no space available.\n          if (flexibleMainDim < 0) {\n            flexibleMainDim = 0;\n          }\n\n          currentFlexChild = firstFlexChild;\n          while (currentFlexChild !== null) {\n            // At this point we know the final size of the element in the main\n            // dimension\n            currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\n              flexibleMainDim * currentFlexChild.style.flex +\n                  getPaddingAndBorderAxis(currentFlexChild, mainAxis)\n            );\n\n            maxWidth = CSS_UNDEFINED;\n            if (isDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                paddingAndBorderAxisResolvedRow;\n            } else if (!isMainRowDirection) {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, resolvedRowAxis) -\n                paddingAndBorderAxisResolvedRow;\n            }\n            maxHeight = CSS_UNDEFINED;\n            if (isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n              maxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n                paddingAndBorderAxisColumn;\n            } else if (isMainRowDirection) {\n              maxHeight = parentMaxHeight -\n                getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n                paddingAndBorderAxisColumn;\n            }\n\n            // And we recursively call the layout algorithm for this child\n            layoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, maxHeight, direction);\n\n            child = currentFlexChild;\n            currentFlexChild = currentFlexChild.nextFlexChild;\n            child.nextFlexChild = null;\n          }\n\n        // We use justifyContent to figure out how to allocate the remaining\n        // space available\n        } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n          if (justifyContent === CSS_JUSTIFY_CENTER) {\n            leadingMainDim = remainingMainDim / 2;\n          } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n            leadingMainDim = remainingMainDim;\n          } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n            remainingMainDim = fmaxf(remainingMainDim, 0);\n            if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n              betweenMainDim = remainingMainDim /\n                (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n            } else {\n              betweenMainDim = 0;\n            }\n          } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n            // Space on the edges is half of the space between elements\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount);\n            leadingMainDim = betweenMainDim / 2;\n          }\n        }\n\n        // <Loop C> Position elements in the main axis and compute dimensions\n\n        // At this point, all the children have their dimensions set. We need to\n        // find their position. In order to do that, we accumulate data in\n        // variables that are also useful to compute the total dimensions of the\n        // container!\n        mainDim += leadingMainDim;\n\n        for (i = firstComplexMain; i < endLine; ++i) {\n          child = node.children[i];\n\n          if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n              isPosDefined(child, leading[mainAxis])) {\n            // In case the child is position absolute and has left/top being\n            // defined, we override the position to whatever the user said\n            // (and margin/border).\n            child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n              getLeadingBorder(node, mainAxis) +\n              getLeadingMargin(child, mainAxis);\n          } else {\n            // If the child is position absolute (without top/left) or relative,\n            // we put it at the current accumulated offset.\n            child.layout[pos[mainAxis]] += mainDim;\n\n            // Define the trailing position accordingly.\n            if (isMainDimDefined) {\n              setTrailingPosition(node, child, mainAxis);\n            }\n\n            // Now that we placed the element, we need to update the variables\n            // We only need to do that for relative elements. Absolute elements\n            // do not take part in that phase.\n            if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n              // The main dimension is the sum of all the elements dimension plus\n              // the spacing.\n              mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n              // The cross dimension is the max of the elements dimension since there\n              // can only be one element in that cross dimension.\n              crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n            }\n          }\n        }\n\n        var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n        if (!isCrossDimDefined) {\n          containerCrossAxis = fmaxf(\n            // For the cross dim, we add both sides at the end because the value\n            // is aggregate via a max function. Intermediate negative values\n            // can mess this computation otherwise\n            boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\n            paddingAndBorderAxisCross\n          );\n        }\n\n        // <Loop D> Position elements in the cross axis\n        for (i = firstComplexCross; i < endLine; ++i) {\n          child = node.children[i];\n\n          if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n              isPosDefined(child, leading[crossAxis])) {\n            // In case the child is absolutely positionned and has a\n            // top/left/bottom/right being set, we override all the previously\n            // computed positions to set it correctly.\n            child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n              getLeadingBorder(node, crossAxis) +\n              getLeadingMargin(child, crossAxis);\n\n          } else {\n            var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n            // For a relative children, we're either using alignItems (parent) or\n            // alignSelf (child) in order to determine the position in the cross axis\n            if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n              /*eslint-disable */\n              // This variable is intentionally re-defined as the code is transpiled to a block scope language\n              var/*css_align_t*/ alignItem = getAlignItem(node, child);\n              /*eslint-enable */\n              if (alignItem === CSS_ALIGN_STRETCH) {\n                // You can only stretch if the dimension has not already been set\n                // previously.\n                if (isUndefined(child.layout[dim[crossAxis]])) {\n                  child.layout[dim[crossAxis]] = fmaxf(\n                    boundAxis(child, crossAxis, containerCrossAxis -\n                      paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n                    // You never want to go smaller than padding\n                    getPaddingAndBorderAxis(child, crossAxis)\n                  );\n                }\n              } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n                // The remaining space between the parent dimensions+padding and child\n                // dimensions+margin.\n                var/*float*/ remainingCrossDim = containerCrossAxis -\n                  paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\n\n                if (alignItem === CSS_ALIGN_CENTER) {\n                  leadingCrossDim += remainingCrossDim / 2;\n                } else { // CSS_ALIGN_FLEX_END\n                  leadingCrossDim += remainingCrossDim;\n                }\n              }\n            }\n\n            // And we apply the position\n            child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n            // Define the trailing position accordingly.\n            if (isCrossDimDefined) {\n              setTrailingPosition(node, child, crossAxis);\n            }\n          }\n        }\n\n        linesCrossDim += crossDim;\n        linesMainDim = fmaxf(linesMainDim, mainDim);\n        linesCount += 1;\n        startLine = endLine;\n      }\n\n      // <Loop E>\n      //\n      // Note(prenaux): More than one line, we need to layout the crossAxis\n      // according to alignContent.\n      //\n      // Note that we could probably remove <Loop D> and handle the one line case\n      // here too, but for the moment this is safer since it won't interfere with\n      // previously working code.\n      //\n      // See specs:\n      // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n      // section 9.4\n      //\n      if (linesCount > 1 && isCrossDimDefined) {\n        var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n            paddingAndBorderAxisCross;\n        var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n        var/*float*/ crossDimLead = 0;\n        var/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n        var/*css_align_t*/ alignContent = getAlignContent(node);\n        if (alignContent === CSS_ALIGN_FLEX_END) {\n          currentLead += remainingAlignContentDim;\n        } else if (alignContent === CSS_ALIGN_CENTER) {\n          currentLead += remainingAlignContentDim / 2;\n        } else if (alignContent === CSS_ALIGN_STRETCH) {\n          if (nodeCrossAxisInnerSize > linesCrossDim) {\n            crossDimLead = (remainingAlignContentDim / linesCount);\n          }\n        }\n\n        var/*int*/ endIndex = 0;\n        for (i = 0; i < linesCount; ++i) {\n          var/*int*/ startIndex = endIndex;\n\n          // compute the line's height and find the endIndex\n          var/*float*/ lineHeight = 0;\n          for (ii = startIndex; ii < childCount; ++ii) {\n            child = node.children[ii];\n            if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n              continue;\n            }\n            if (child.lineIndex !== i) {\n              break;\n            }\n            if (!isUndefined(child.layout[dim[crossAxis]])) {\n              lineHeight = fmaxf(\n                lineHeight,\n                child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n              );\n            }\n          }\n          endIndex = ii;\n          lineHeight += crossDimLead;\n\n          for (ii = startIndex; ii < endIndex; ++ii) {\n            child = node.children[ii];\n            if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n              continue;\n            }\n\n            var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n            if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n              child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n            } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n              var/*float*/ childHeight = child.layout[dim[crossAxis]];\n              child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n            } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n              child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n              // TODO(prenaux): Correctly set the height of items with undefined\n              //                (auto) crossAxis dimension.\n            }\n          }\n\n          currentLead += lineHeight;\n        }\n      }\n\n      var/*bool*/ needsMainTrailingPos = false;\n      var/*bool*/ needsCrossTrailingPos = false;\n\n      // If the user didn't specify a width or height, and it has not been set\n      // by the container, then we set it via the children.\n      if (!isMainDimDefined) {\n        node.layout[dim[mainAxis]] = fmaxf(\n          // We're missing the last padding at this point to get the final\n          // dimension\n          boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n          // We can never assign a width smaller than the padding and borders\n          paddingAndBorderAxisMain\n        );\n\n        if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n            mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n          needsMainTrailingPos = true;\n        }\n      }\n\n      if (!isCrossDimDefined) {\n        node.layout[dim[crossAxis]] = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n          paddingAndBorderAxisCross\n        );\n\n        if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n            crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n          needsCrossTrailingPos = true;\n        }\n      }\n\n      // <Loop F> Set trailing position if necessary\n      if (needsMainTrailingPos || needsCrossTrailingPos) {\n        for (i = 0; i < childCount; ++i) {\n          child = node.children[i];\n\n          if (needsMainTrailingPos) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          if (needsCrossTrailingPos) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n\n      // <Loop G> Calculate dimensions for absolutely positioned elements\n      currentAbsoluteChild = firstAbsoluteChild;\n      while (currentAbsoluteChild !== null) {\n        // Pre-fill dimensions when using absolute position and both offsets for\n        // the axis are defined (either both left and right or top and bottom).\n        for (ii = 0; ii < 2; ii++) {\n          axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(currentAbsoluteChild, axis) &&\n              isPosDefined(currentAbsoluteChild, leading[axis]) &&\n              isPosDefined(currentAbsoluteChild, trailing[axis])) {\n            currentAbsoluteChild.layout[dim[axis]] = fmaxf(\n              boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\n                getBorderAxis(node, axis) -\n                getMarginAxis(currentAbsoluteChild, axis) -\n                getPosition(currentAbsoluteChild, leading[axis]) -\n                getPosition(currentAbsoluteChild, trailing[axis])\n              ),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n            );\n          }\n\n          if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n              !isPosDefined(currentAbsoluteChild, leading[axis])) {\n            currentAbsoluteChild.layout[leading[axis]] =\n              node.layout[dim[axis]] -\n              currentAbsoluteChild.layout[dim[axis]] -\n              getPosition(currentAbsoluteChild, trailing[axis]);\n          }\n        }\n\n        child = currentAbsoluteChild;\n        currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\n        child.nextAbsoluteChild = null;\n      }\n    }\n\n    function layoutNode(node, parentMaxWidth, parentMaxHeight, parentDirection) {\n      node.shouldUpdate = true;\n\n      var direction = node.style.direction || CSS_DIRECTION_LTR;\n      var skipLayout =\n        !node.isDirty &&\n        node.lastLayout &&\n        node.lastLayout.requestedHeight === node.layout.height &&\n        node.lastLayout.requestedWidth === node.layout.width &&\n        node.lastLayout.parentMaxWidth === parentMaxWidth &&\n        node.lastLayout.parentMaxHeight === parentMaxHeight &&\n        node.lastLayout.direction === direction;\n\n      if (skipLayout) {\n        node.layout.width = node.lastLayout.width;\n        node.layout.height = node.lastLayout.height;\n        node.layout.top = node.lastLayout.top;\n        node.layout.left = node.lastLayout.left;\n      } else {\n        if (!node.lastLayout) {\n          node.lastLayout = {};\n        }\n\n        node.lastLayout.requestedWidth = node.layout.width;\n        node.lastLayout.requestedHeight = node.layout.height;\n        node.lastLayout.parentMaxWidth = parentMaxWidth;\n        node.lastLayout.parentMaxHeight = parentMaxHeight;\n        node.lastLayout.direction = direction;\n\n        // Reset child layouts\n        node.children.forEach(function(child) {\n          child.layout.width = undefined;\n          child.layout.height = undefined;\n          child.layout.top = 0;\n          child.layout.left = 0;\n        });\n\n        layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);\n\n        node.lastLayout.width = node.layout.width;\n        node.lastLayout.height = node.layout.height;\n        node.lastLayout.top = node.layout.top;\n        node.lastLayout.left = node.layout.left;\n      }\n    }\n\n    return {\n      layoutNodeImpl: layoutNodeImpl,\n      computeLayout: layoutNode,\n      fillNodes: fillNodes\n    };\n  })();\n\n  // This module export is only used for the purposes of unit testing this file. When\n  // the library is packaged this file is included within css-layout.js which forms\n  // the public API.\n  if (typeof exports === 'object') {\n    module.exports = computeLayout;\n  }\n\n\n    return function(node) {\n      /*eslint-disable */\n      // disabling ESLint because this code relies on the above include\n      computeLayout.fillNodes(node);\n      computeLayout.computeLayout(node);\n      /*eslint-enable */\n    };\n  }));\n\n  !window.addEventListener && window.attachEvent && (function () {\n    Window.prototype.addEventListener = HTMLDocument.prototype.addEventListener = Element.prototype.addEventListener = function addEventListener(type, listener) {\n      this.attachEvent('on' + type, listener);\n    };\n\n    Window.prototype.removeEventListener = HTMLDocument.prototype.removeEventListener = Element.prototype.removeEventListener = function removeEventListener(type, listener) {\n      this.detachEvent('on' + type, listener);\n    };\n  })();\n\n  flexibility.detect = function detect() {\n    var node = document.createElement('p');\n\n    try {\n      node.style.display = 'flex';\n\n      return node.style.display === 'flex';\n    } catch (error) {\n      return false;\n    }\n  };\n\n  if (!flexibility.detect() && document.attachEvent && document.documentElement.currentStyle) {\n    document.attachEvent('onreadystatechange', function () {\n      flexibility.onresize({\n        target: document.documentElement\n      });\n    });\n  }\n\n  flexibility.init = function init(node) {\n    // get details from node\n    var details = node.onlayoutcomplete;\n\n    // conditionally generate details\n    if (!details) {\n      details = node.onlayoutcomplete = {\n        node:     node,\n        style:    {},\n        children: []\n      };\n    }\n\n    // store display style in details\n    details.style.display = node.currentStyle['-js-display'] || node.currentStyle.display;\n\n    // return details\n    return details;\n  };\n\n  // define delay\n  var SECOND = 1000;\n  var FRAMES_PER_SECOND = 15;\n  var VIEWPORT_ELEMENT = document.documentElement;\n  var VIEWPORT_WIDTH = 0;\n  var VIEWPORT_HEIGHT = 0;\n  var TIMEOUT;\n\n  flexibility.onresize = function resize(event) {\n    // if the screen width has changed\n    if (VIEWPORT_ELEMENT.clientWidth !== VIEWPORT_WIDTH || VIEWPORT_ELEMENT.clientHeight !== VIEWPORT_HEIGHT) {\n      // update the cached screen width\n      VIEWPORT_WIDTH = VIEWPORT_ELEMENT.clientWidth;\n      VIEWPORT_HEIGHT = VIEWPORT_ELEMENT.clientHeight;\n\n      // clear existing timeouts\n      clearTimeout(TIMEOUT);\n\n      // remove resize listener\n      window.removeEventListener('resize', flexibility.onresize);\n\n      // get resize target\n      var target = event.target && event.target.nodeType === 1 ? event.target : document.documentElement;\n\n      // walk resize target\n      flexibility.walk(target);\n\n      // restore resize listener\n      TIMEOUT = setTimeout(function () {\n        window.addEventListener('resize', flexibility.onresize);\n      }, SECOND / FRAMES_PER_SECOND);\n    }\n  };\n\n  var CSS_FLEX_CONTAINER_PROPERTIES = {\n    alignContent: {\n      initial: 'stretch',\n      valid:   /^(flex-start|flex-end|center|space-between|space-around|stretch)/\n    },\n    alignItems: {\n      initial: 'stretch',\n      valid:   /^(flex-start|flex-end|center|baseline|stretch)$/\n    },\n    boxSizing: {\n      initial: 'content-box',\n      valid: /^(border-box|content-box)$/\n    },\n    flexDirection: {\n      initial: 'row',\n      valid:   /^(row|row-reverse|column|column-reverse)$/\n    },\n    flexWrap: {\n      initial: 'nowrap',\n      valid:   /^(nowrap|wrap|wrap-reverse)$/\n    },\n    justifyContent: {\n      initial: 'flex-start',\n      valid:   /^(flex-start|flex-end|center|space-between|space-around)$/\n    }\n  };\n\n  flexibility.updateFlexContainerCache = function updateFlexContainerCache(details) {\n    // get style details\n    var style  = details.style;\n    var getCSS = details.node.currentStyle;\n    var ie9CSS = details.node.style;\n    var ffbCSS = {};\n\n    // flex-flow\n    (getCSS['flex-flow'] || ie9CSS['flex-flow'] || '').replace(/^(row|row-reverse|column|column-reverse)\\s+(nowrap|wrap|wrap-reverse)$/i, function ($0, flexDirection, flexWrap) {\n      ffbCSS.flexDirection = flexDirection;\n      ffbCSS.flexWrap = flexWrap;\n    });\n\n    // store each flex container property value\n    for (var key in CSS_FLEX_CONTAINER_PROPERTIES) {\n      var kabobKey = key.replace(/[A-Z]/g, '-$&').toLowerCase();\n      var keyValue = CSS_FLEX_CONTAINER_PROPERTIES[key];\n      var cssValue = getCSS[kabobKey] || ie9CSS[kabobKey];\n\n      style[key] = keyValue.valid.test(cssValue) ? cssValue : ffbCSS[key] || keyValue.initial;\n    }\n  };\n\n  var CSS_FLEX_ITEM_PROPERTIES = {\n    alignSelf: {\n      initial: 'auto',\n      valid:   /^(auto|flex-start|flex-end|center|baseline|stretch)$/\n    },\n    boxSizing: {\n      initial: 'content-box',\n      valid: /^(border-box|content-box)$/\n    },\n    flexBasis: {\n      initial: 'auto',\n      valid:   /^((?:[-+]?0|[-+]?[0-9]*\\.?[0-9]+(?:%|ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmax|vmin|vw))|auto|fill|max-content|min-content|fit-content|content)$/\n    },\n    flexGrow: {\n      initial: 0,\n      valid:   /^\\+?(0|[1-9][0-9]*)$/\n    },\n    flexShrink: {\n      initial: 0,\n      valid:   /^\\+?(0|[1-9][0-9]*)$/\n    },\n    order: {\n      initial: 0,\n      valid:   /^([-+]?[0-9]+)$/\n    }\n  };\n\n  flexibility.updateFlexItemCache = function updateFlexItemCache(details) {\n    // get style details\n    var style  = details.style;\n    var getCSS = details.node.currentStyle;\n    var ie9CSS = details.node.style;\n    var ffbCSS = {};\n\n    // flex\n    (getCSS.flex || ie9CSS.flex || '').replace(/^\\+?(0|[1-9][0-9]*)/, function ($0) {\n      ffbCSS.flexGrow = $0;\n    });\n\n    // store each flex item property value\n    for (var key in CSS_FLEX_ITEM_PROPERTIES) {\n      var kabobKey = key.replace(/[A-Z]/g, '-$&').toLowerCase();\n      var keyValue = CSS_FLEX_ITEM_PROPERTIES[key];\n      var cssValue = getCSS[kabobKey] || ie9CSS[kabobKey];\n\n      style[key] = keyValue.valid.test(cssValue) ? cssValue : ffbCSS[key] || keyValue.initial;\n\n      if (typeof keyValue.initial === 'number') {\n        style[key] = parseFloat(style[key]);\n      }\n    }\n  };\n\n  var CSS_RESET_TEXT = 'border:0 solid;clip:rect(0 0 0 0);display:inline-block;font:0/0 serif;margin:0;max-height:none;max-width:none;min-height:0;min-width:0;overflow:hidden;padding:0;position:absolute;width:1em;';\n\n  var CSS_BORDER_WIDTHS = {\n    medium: 4,\n    none:   0,\n    thick:  6,\n    thin:   2\n  };\n\n  var CSS_LENGTHS = {\n    borderBottomWidth: 0,\n    borderLeftWidth: 0,\n    borderRightWidth: 0,\n    borderTopWidth: 0,\n    height: 0,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 0,\n    marginBottom: 0,\n    marginLeft: 0,\n    marginRight: 0,\n    marginTop: 0,\n    maxHeight: 0,\n    maxWidth: 0,\n    minHeight: 0,\n    minWidth: 0,\n    width: 0\n  };\n\n  var CSS_LENGTH_REGEX = /^([-+]?0|[-+]?[0-9]*\\.?[0-9]+)/;\n\n  var CSS_FULL_LENGTH = 100;\n\n  flexibility.updateLengthCache = function updateLengthCache(details) {\n    // get style details\n    var node = details.node;\n    var style = details.style;\n\n    // get node parent\n    var parentNode  = node.parentNode;\n    var parentWidth;\n    var parentHeight;\n    var parentLength;\n\n    // create clone element\n    var clonex = document.createElement('_');\n\n    var setCSS = clonex.runtimeStyle;\n\n    var getCSS = node.currentStyle;\n\n    setCSS.cssText = CSS_RESET_TEXT + 'font-size:' + getCSS.fontSize;\n\n    // insert clone after node\n    parentNode.insertBefore(clonex, node.nextSibling);\n\n    style.fontSize = clonex.offsetWidth;\n\n    setCSS.fontSize = style.fontSize + 'px';\n\n    for (var key in CSS_LENGTHS) {\n      var cssValue = getCSS[key];\n\n      // if the value is a length or if it is \"auto\" not on width or height\n      if (CSS_LENGTH_REGEX.test(cssValue) || cssValue === 'auto' && !/(width|height)/i.test(key)) {\n        // if the value is a percentage length\n        if (/%$/.test(cssValue)) {\n          // cache the appropriate parent metric\n          if (/^(bottom|height|top)$/.test(key)) {\n            if (!parentHeight) {\n              parentHeight = parentNode.offsetHeight;\n            }\n\n            parentLength = parentHeight;\n          } else {\n            if (!parentWidth) {\n              parentWidth = parentNode.offsetWidth;\n            }\n\n            parentLength = parentWidth;\n          }\n\n          style[key] = parseFloat(cssValue) * parentLength / CSS_FULL_LENGTH;\n        } else {\n          setCSS.width = cssValue;\n\n          style[key] = clonex.offsetWidth;\n        }\n      } else if (/^border/.test(key) && cssValue in CSS_BORDER_WIDTHS) {\n        style[key] = CSS_BORDER_WIDTHS[cssValue];\n      } else {\n        delete style[key];\n      }\n    }\n\n    // remove clone\n    parentNode.removeChild(clonex);\n\n    // redefine borders without style\n    if (getCSS.borderTopStyle    === 'none') {\n      style.borderTopWidth    = 0;\n    }\n\n    if (getCSS.borderRightStyle  === 'none') {\n      style.borderRightWidth  = 0;\n    }\n\n    if (getCSS.borderBottomStyle === 'none') {\n      style.borderBottomWidth = 0;\n    }\n\n    if (getCSS.borderLeftStyle   === 'none') {\n      style.borderLeftWidth   = 0;\n    }\n\n    // provide width and height fallbacks\n    if (!style.width && !style.minWidth) {\n      if (/flex/.test(style.display)) {\n        style.width = node.offsetWidth;\n      } else {\n        style.minWidth = node.offsetWidth;\n      }\n    }\n\n    // provide width and height fallbacks\n    if (!style.height && !style.minHeight) {\n      if (!/flex/.test(style.display)) {\n        style.minHeight = node.offsetHeight;\n      }\n    }\n  };\n\n  flexibility.walk = function walk(node) {\n    // initialize node\n    var details = flexibility.init(node);\n\n    // get display\n    var style   = details.style;\n    var display = style.display;\n\n    // skip display:none elements\n    if (display === 'none') {\n      return {};\n    }\n\n    // detect flex\n    var isFlex  = display.match(/^(inline)?flex$/);\n\n    // conditionally style flex container\n    if (isFlex) {\n      flexibility.updateFlexContainerCache(details);\n\n      node.runtimeStyle.cssText = 'display:' + (isFlex[1] ? 'inline-block' : 'block');\n\n      details.children = [];\n    }\n\n    // walk children of the current node\n    Array.prototype.forEach.call(node.childNodes, function (childNode, childNodeIndex) {\n      // if the child is an element\n      if (childNode.nodeType === 1) {\n        // walk the child element\n        var childDetails = flexibility.walk(childNode);\n        var childStyle   = childDetails.style;\n\n        childDetails.index = childNodeIndex;\n\n        // if the parent is a flex container\n        if (isFlex) {\n          // get the flex item styles\n          flexibility.updateFlexItemCache(childDetails);\n\n          // inherit self alignment from container item alignment\n          if (childStyle.alignSelf === 'auto') {\n            childStyle.alignSelf = style.alignItems;\n          }\n\n          childStyle.flex = childStyle.flexGrow;\n\n          // overwrite child runtime style\n          childNode.runtimeStyle.cssText = 'display:inline-block';\n\n          // add item to parent flex\n          details.children.push(childDetails);\n        }\n      }\n    });\n\n    // if the element is a flex container\n    if (isFlex) {\n      // calculate each flex item length\n      details.children.forEach(function (child) {\n        flexibility.updateLengthCache(child);\n      });\n\n      // sort flex items by order or original position\n      details.children.sort(function (childA, childB) {\n        return childA.style.order - childB.style.order || childA.index - childB.index;\n      });\n\n      // if the flex container direction is reversed\n      if (/-reverse$/.test(style.flexDirection)) {\n        // reverse the flex item order\n        details.children.reverse();\n\n        // remove the flex container reversal\n        style.flexDirection = style.flexDirection.replace(/-reverse$/, '');\n\n        // conditionally flip flex container content justification\n        if (style.justifyContent === 'flex-start') {\n          style.justifyContent = 'flex-end';\n        } else if (style.justifyContent === 'flex-end') {\n          style.justifyContent = 'flex-start';\n        }\n      }\n\n      // update flex container lengths\n      flexibility.updateLengthCache(details);\n\n      // remove old layout results\n      delete details.lastLayout;\n      delete details.layout;\n\n      // CSS-LAYOUT PATCH: adjust border widths\n      var borderTopWidth = style.borderTopWidth;\n      var borderBottomWidth = style.borderBottomWidth;\n\n      style.borderTopWidth = 0;\n      style.borderBottomWidth = 0;\n      style.borderLeftWidth = 0;\n\n      if (style.flexDirection === 'column') {\n        style.width -= style.borderRightWidth;\n      }\n\n      // calculate the layout\n      flexibility.computeLayout(details);\n\n      // style the flex container\n      node.runtimeStyle.cssText = 'box-sizing:border-box;display:block;position:relative;width:' + (details.layout.width + style.borderRightWidth) + 'px;height:' + (details.layout.height + borderTopWidth + borderBottomWidth) + 'px';\n\n      // CSS-LAYOUT PATCH: calculate stretched column width and height\n      var maxLength = [];\n      var maxIndex = 1;\n\n      var angle = style.flexDirection === 'column' ? 'width' : 'height';\n\n      details.children.forEach(function (child) {\n        maxLength[child.lineIndex] = Math.max(maxLength[child.lineIndex] || 0, child.layout[angle]);\n\n        maxIndex = Math.max(maxIndex, child.lineIndex + 1);\n      });\n\n      // style each flex item\n      details.children.forEach(function (child) {\n        var layout = child.layout;\n\n        if (child.style.alignSelf === 'stretch') {\n          layout[angle] = maxLength[child.lineIndex];\n        }\n\n        child.node.runtimeStyle.cssText = 'box-sizing:border-box;display:block;position:absolute;margin:0;width:' + layout.width + 'px;height:' + layout.height + 'px;top:' + layout.top + 'px;left:' + layout.left + 'px';\n      });\n    }\n\n    return details;\n  };\n})();\n"],"sourceRoot":"../.."}